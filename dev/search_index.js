var documenterSearchIndex = {"docs":
[{"location":"visualization/#Visualization-Guide","page":"Visualization","title":"Visualization Guide","text":"","category":"section"},{"location":"visualization/#Overview","page":"Visualization","title":"Overview","text":"BayesInteractomics provides visualization functions at three levels:\n\nPipeline plots: Automatically generated by run_analysis (volcano, convergence, evidence)\nPer-protein plots: Detailed inference diagnostics for individual proteins\nDiagnostic plots: Model validation visualizations (PPC, residuals, calibration)","category":"section"},{"location":"visualization/#Pipeline-Plots","page":"Visualization","title":"Pipeline Plots","text":"These are generated automatically by run_analysis and saved to the paths specified in OutputFiles.","category":"section"},{"location":"visualization/#Volcano-Plot","page":"Visualization","title":"Volcano Plot","text":"Shows posterior probability vs. mean log₂ fold-change for all proteins:\n\nplot_analysis(copula_df, \"volcano.png\")\n\nHighlights high-confidence interactors with strong enrichment.","category":"section"},{"location":"visualization/#Evidence-Plot","page":"Visualization","title":"Evidence Plot","text":"Distribution of individual and combined Bayes factors:\n\nevidence_plot(copula_df)\n\nThree-panel plot showing enrichment, correlation, and detection BFs.","category":"section"},{"location":"visualization/#Rank-Rank-Plot","page":"Visualization","title":"Rank-Rank Plot","text":"Compares rankings between individual models and the combined result:\n\nrank_rank_plot(copula_df)\n\nHelps identify proteins where individual models disagree.","category":"section"},{"location":"visualization/#Convergence-Plot","page":"Visualization","title":"Convergence Plot","text":"EM algorithm convergence diagnostics (generated from EMResult):\n\nLog-likelihood trajectory\nMixing proportion (π₁) trajectory\nCopula parameter evolution","category":"section"},{"location":"visualization/#Per-Protein-Plots","page":"Visualization","title":"Per-Protein Plots","text":"These can be generated during analyse() by setting the corresponding flags to true, or called manually for specific proteins.","category":"section"},{"location":"visualization/#Posterior-Distribution-Plot","page":"Visualization","title":"Posterior Distribution Plot","text":"plot_inference_results(hbm_result, file = \"posterior.png\")\nplot_inference_results(bayes_result, file = \"posterior.png\")\n\nShows posterior vs. prior distributions for sample and control means.","category":"section"},{"location":"visualization/#Log-Fold-Change-Plot","page":"Visualization","title":"Log₂ Fold-Change Plot","text":"plot_log2fc(bayes_result, real_log2fc, file = \"log2fc.png\")\n\nMultiple dispatch methods for:\n\nBayesResult: Extracts HBM result automatically\nHBMResult: Direct HBM posterior visualization\nRaw posterior/prior distributions","category":"section"},{"location":"visualization/#Regression-Plot","page":"Visualization","title":"Regression Plot","text":"plot_regression(bayes_result, x, y, file = \"regression.png\")\n\nDraws posterior predictive regression lines over observed data. Available for:\n\nSingle-protocol experiments (RegressionResultSingleProtocol)\nMulti-protocol experiments (RegressionResultMultipleProtocols): 3-panel layout with global, per-protocol, and residual panels","category":"section"},{"location":"visualization/#Bayes-Factor-Range-Plot","page":"Visualization","title":"Bayes Factor Range Plot","text":"plot_bayesrange(bayes_result, protocol_positions, protein_name,\n    file = \"bayesrange.png\")\n\nShows how the Bayes factor changes as a function of the log₂FC threshold, separately for each protocol and the global estimate. Useful for understanding the sensitivity of the enrichment evidence.","category":"section"},{"location":"visualization/#Diagnostic-Plots","page":"Visualization","title":"Diagnostic Plots","text":"See the Diagnostics and Model Validation page for details. Summary:\n\nFunction Purpose\nppc_density_plot Observed vs. predicted density\nppc_pvalue_histogram PPC p-value distribution\nresidual_qq_plot Q-Q plot of standardized residuals\nscale_location_plot Detect heteroscedasticity\nresidual_distribution_plot Residual shape\ncalibration_plot Predicted vs. empirical probabilities\ncalibration_comparison_plot Compare calibration criteria\npit_histogram_plot Probability Integral Transform\nnu_optimization_plot WAIC vs. Student-t ν\nbb_ppc_summary_plot Beta-Bernoulli PPC summary\nsensitivity_tornado_plot Prior impact ranking\nsensitivity_heatmap Posterior across prior settings\nsensitivity_rank_correlation Ranking stability","category":"section"},{"location":"visualization/#Differential-Analysis-Plots","page":"Visualization","title":"Differential Analysis Plots","text":"See the Differential Interaction Analysis page for details. Summary:\n\nFunction Purpose\ndifferential_volcano_plot Differential BF vs. significance\ndifferential_evidence_plot Per-evidence differential BFs\ndifferential_scatter_plot Condition A vs. B comparison\ndifferential_classification_plot Classification summary bar chart\ndifferential_ma_plot MA plot for bias detection","category":"section"},{"location":"visualization/#Network-Plots","page":"Visualization","title":"Network Plots","text":"See the Network Analysis page for details:\n\nplot_network(net, layout = :spring, node_size = :degree, show_labels = true)\nsave_network_plot(net, \"network.png\")","category":"section"},{"location":"visualization/#Customization-Tips","page":"Visualization","title":"Customization Tips","text":"","category":"section"},{"location":"visualization/#Saving-Plots","page":"Visualization","title":"Saving Plots","text":"All plot functions return StatsPlots plot objects. Save with:\n\nusing StatsPlots\nplt = volcano_plot(df)\nsavefig(plt, \"plot.png\")   # PNG\nsavefig(plt, \"plot.svg\")   # SVG\nsavefig(plt, \"plot.pdf\")   # PDF","category":"section"},{"location":"visualization/#Image-Format","page":"Visualization","title":"Image Format","text":"Control the default format in OutputFiles:\n\noutput = OutputFiles(\"/results\", image_ext = \".svg\")","category":"section"},{"location":"visualization/#Plot-Size-and-Resolution","page":"Visualization","title":"Plot Size and Resolution","text":"plt = volcano_plot(df)\nplot!(plt, size = (1200, 800), dpi = 300)\nsavefig(plt, \"publication_figure.png\")","category":"section"},{"location":"visualization/#API-Reference","page":"Visualization","title":"API Reference","text":"","category":"section"},{"location":"visualization/#Pipeline-Plots-2","page":"Visualization","title":"Pipeline Plots","text":"","category":"section"},{"location":"visualization/#Per-Protein-Plots-2","page":"Visualization","title":"Per-Protein Plots","text":"","category":"section"},{"location":"visualization/#BayesInteractomics.plot_analysis","page":"Visualization","title":"BayesInteractomics.plot_analysis","text":"plot_analysis(copula_df, file = \"results_copula.png\")\n\nCreate and save a plot summarizing the results of the copula analysis.\n\nThe plot consists of four subplots:\n\nScatter plot of log10(BF) vs log10(BF enrichment)\nScatter plot of log10(BF) vs log10(BF correlation)\nScatter plot of log10(BF) vs log10(BF detected)\nHistograms of log10(BF), log10(enrichment), log10(correlation), and log10(Detection)\n\nArguments\n\ncopula_df: A DataFrame containing the results of the copula analysis.\nfile: The name of the file to save the plot to. Defaults to \"results_copula.png\".\n\nReturns\n\nA plot object.\n\n\n\n\n\n","category":"function"},{"location":"visualization/#BayesInteractomics.plot_results","page":"Visualization","title":"BayesInteractomics.plot_results","text":"plot_results(df::DataFrame)\n\nCreate a plot summarizing the results of the analysis.\n\nThe plot consists of five subplots:\n\nDensity plot of the posterior probability.\nDensity plot of the meta-classifier.\nDensity plot of the DNN.\nScatter plot of the meta-classifier vs the posterior probability.\nScatter plot of the DNN vs the posterior probability.\n\nArguments\n\ndf: A DataFrame containing the results of the analysis.\n\nReturns\n\nA plot object.\n\n\n\n\n\n","category":"function"},{"location":"visualization/#BayesInteractomics.evidence_plot","page":"Visualization","title":"BayesInteractomics.evidence_plot","text":"evidence_plot(df)\n\nCreate a plot summarizing the evidence contribution.\n\nThe plot consists of four subplots:\n\nScatter plot of log10(BF-enrichment) vs log10(BF-correlation). The color indicates the Bayesian false discovery rate.\nScatter plot of log10(BF-enrichment) vs log10(BF-detection). The color indicates the Bayesian false discovery rate.\nScatter plot of log10(BF-correlation) vs log10(BF-detection). The color indicates the Bayesian false discovery rate.\nDensity plot of the Bayesian false discovery rate.\n\nArguments\n\ndf: A DataFrame containing the results of the analysis.\n\nReturns\n\nA plot object.\n\n\n\n\n\n","category":"function"},{"location":"visualization/#BayesInteractomics.rank_rank_plot","page":"Visualization","title":"BayesInteractomics.rank_rank_plot","text":"rank_rank_plot(df; legend_pos = :topleft)\n\nCreate a rank-rank plot to visualize interactome analysis results.\n\nThis function generates a scatter plot where each point represents a protein. The plot visualizes four different metrics:\n\nx-axis: log10(BF) - The decadic logarithm of the Bayes Factor, indicating the overall evidence for interaction.\ny-axis: log2FC - The mean log2 fold change, indicating the magnitude of enrichment.\nColor: BF Correlation - The winsorized decadic logarithm of the Bayes Factor for correlation between replicates. Values are clamped between the 1st and 99th percentile.\nSize: BF Detected - The rank of the decadic logarithm of the Bayes Factor for detection across replicates.\n\nArguments\n\ndf::DataFrame: A DataFrame containing the results of the analysis. It must include the columns BF, bf_correlation, bf_detected, mean_log2FC, and Protein.\nlegend_pos: The position of the legend. Defaults to :topleft.\n\nReturns\n\nA plot object representing the rank-rank plot. \n\n\n\n\n\n","category":"function"},{"location":"visualization/#BayesInteractomics.volcano_plot","page":"Visualization","title":"BayesInteractomics.volcano_plot","text":"volcano_plot(df; legend_pos = :topleft)\n\nCreate a volcano plot.\n\nArguments\n\ndf: A DataFrame containing the results of the analysis.\nlegend_pos: The position of the legend. Defaults to :topleft.\n\nReturns\n\nA plot object.\n\n\n\n\n\n","category":"function"},{"location":"visualization/#BayesInteractomics.plot_inference_results","page":"Visualization","title":"BayesInteractomics.plot_inference_results","text":"plot_inference_results(result::HBMResult; file::Union{String, Nothing} = nothing)\n\nDescription:\nThis function plots the inference results for a given protein. \n\nArgs:\n  - result<:HBMResult: result object of type HBMResult\n  - protein_name<:AbstractString: name of the protein\n\nKeyword Args:\n  - file<:AbstractString: name of the file to save the plot. If not provided, the plot is not saved\n\nReturns:\n  - nothing\n\n\n\n\n\nplot_inference_results(\nposterior_samples::Normal, posterior_controls::Normal, \nprior_samples::Normal, prior_controls::Normal, title::S\n) where {S<:AbstractString}\n\nDescription:\nThis function plots the inference results for a given protein. \n\nArgs:\n  - posterior_samples<:Normal: posterior inference result object of type InferenceResult\n  - posterior_controls<:Normal: posterior inference result object of type InferenceResult\n  - prior_samples<:Normal: prior inference result object of type InferenceResult\n  - prior_controls<:Normal: prior inference result object of type InferenceResult\n  - title<:AbstractString: title of the plot\n\nReturns:\n  - Plot object\n\n\n\n\n\nplot_inference_results(result::BayesResult; file::Union{String, Nothing} = nothing)\n\nDescription:\nThis function plots the inference results for a given protein. \n\nArgs:\n  - result<:BayesResult: result of Bayesian inference for a given protein\n\nKeyword Args:\n  - file<:AbstractString: name of the file to save the plot. If not provided, the plot is not saved\n\nReturns:\n  - Plot of posterior and prior distributions\n\n\n\n\n\n","category":"function"},{"location":"visualization/#BayesInteractomics.plot_log2fc","page":"Visualization","title":"BayesInteractomics.plot_log2fc","text":"plot_log2fc(\nposterior::Vector{MixtureModel}, prior::InferenceResult; \nfile::Union{S, Nothing} = nothing, threshold::F = 0.0\n) where {S<:AbstractString, F<:AbstractFloat}\n\nDescription: \nThis function plots the inference results (log2-fold-changes) for a given protein with\nmultiple imputation.\n\nArgs:\n- posterior:: result of the Bayesian inference for a given protein. A Vector{MixtureModel} where each\n              element corresponds to a parameter.\n- prior::     prior inference result object of type InferenceResult\n\nKeyword Args:\n- file<:AbstractString: name of the file to save the plot. If not provided, the plot is not saved\n- threshold<:AbstractFloat: threshold value for log2FC\n\n\n\n\n\nplot_log2fc(result::BayesResult, reallog2fc::Vector{Union{Missing, F}}; file::Union{S, Nothing} = nothing, threshold::F = 0.0) where {S<:AbstractString, F<:AbstractFloat}\n\nDescription:\nThis function plots the inference results (log2-fold-changes) for a given protein.  \n\nArgs:\n  - result<:BayesResult:            result of Bayesian inference for a given protein. \n  - reallog2fc<:AbstractFloat:      observed log2-fold-change for the protein.\n\nKeyword Args:\n  - file<:AbstractString:       name of the file to save the plot. If not provided, the plot is not saved.\n  - threshold<:AbstractFloat:   threshold above which a fold change is considered significant (i.e., position \n                                of the red dashed vertical line). Default is 0.0. The same threshold should be \n                                used for all proteins and should be identical to the one used to compute the \n                                posterior probability and Bayes Factor.  \n\nReturns:\n  - plot of the log2-fold-change a given protein\n\n\n\n\n\nplot_log2fc(result::HBMResult, reallog2fc::Vector{Union{Missing, F}}; file::Union{S, Nothing} = nothing, threshold::F = 0.0) where {S<:AbstractString, F<:AbstractFloat}\n\nDescription:\nThis function plots the inference results (log2-fold-changes) for a given protein.  \n\nArgs:\n  - result<:HBMResult:              result of Bayesian inference for a given protein. \n  - reallog2fc<:AbstractFloat:      observed log2-fold-change for the protein.\n\nKeyword Args:\n  - file<:AbstractString:       name of the file to save the plot. If not provided, the plot is not saved.\n  - threshold<:AbstractFloat:   threshold above which a fold change is considered significant (i.e., position \n                                of the red dashed vertical line). Default is 0.0. The same threshold should be \n                                used for all proteins and should be identical to the one used to compute the \n                                posterior probability and Bayes Factor.  \n\nReturns:\n  - plot of the log2-fold-change a given protein\n\n\n\n\n\nplot_log2fc(posterior::Normal{F}, prior::Normal{F},reallog2fc::Union{Missing, F}, threshold::F = 0.0) where {F<:AbstractFloat}\n\nDescription:\n    This function plots the inference results (log2-fold-changes) for a given protein.  \n\nArgs:\n  - posterior:Normal{F}             posterior distribution of the log2-fold-change\n  - prior:                          prior distribution of the log2-fold-change\n  - reallog2fc<:AbstractFloat:      observed log2-fold-change for the protein.\n  - i:                              index of the parameter\n\nKeyword Args:\n  - threshold<:AbstractFloat:   threshold above which a fold change is considered significant (i.e., position \n                                of the red dashed vertical line). Default is 0.0. The same threshold should be \n                                used for all proteins and should be identical to the one used to compute the \n                                posterior probability and Bayes Factor.  \n\nReturns:\n  - plot of the log2-fold-change a given protein\n\n\n\n\n\nplot_log2fc(posterior::MixtureModel, prior::MixtureModel, threshold::F, i; nsamples = 1_000_000) where {F<:AbstractFloat}\n\nDescription:\n    This function plots the inference results (log2-fold-changes) for a given protein. This method should be used if missing\n        values have been imputed by Multiple Imputation   \n\nArgs:\n  - posterior::MixtureModel     posterior distribution of the log2-fold-change\n  - prior::Normal               prior distribution of the log2-fold-change\n  - i:                          index of the parameter\n  - threshold<:AbstractFloat:   threshold above which a fold change is considered significant (i.e., position \n                                of the red dashed vertical line). Default is 0.0. The same threshold should be \n                                used for all proteins and should be identical to the one used to compute the \n                                posterior probability and Bayes Factor.  \n\nKeyword Args:\n  - nsamples:                   Number of samples that are drawn from the MixtureModel for plotting\n\nReturns:\n  - plot of the log2-fold-change a given protein\n\n\n\n\n\n","category":"function"},{"location":"visualization/#BayesInteractomics.plot_regression","page":"Visualization","title":"BayesInteractomics.plot_regression","text":"plot_regression(result::BayesResult, x::Array, y::Array; nlines = 100, file::Union{S, Nothing} = nothing) where {S<:AbstractString}\n\n\n\n\n\nplot_regression(result::RegressionResultSingleProtocol, protein_name, x, y; nlines=100, file=nothing)\n\nPlot regression model fit for a single-protocol experiment.\n\nDraws nlines posterior predictive regression lines over the observed data, showing the posterior uncertainty in slope and intercept.\n\nArguments\n\nresult::RegressionResultSingleProtocol: Fitted regression result.\nprotein_name::String: Protein name for the plot title.\nx::Array: Reference (bait) protein abundance values.\ny::Array: Prey protein abundance values.\n\nKeywords\n\nnlines::Int=100: Number of posterior regression lines to draw.\nfile::Union{String, Nothing}=nothing: If provided, save the plot to this path.\n\nReturns\n\nA StatsPlots plot object.\n\n\n\n\n\nplot_regression(result::RegressionResultMultipleProtocols, protein_name, x, y; nlines=100, file=nothing)\n\nPlot regression model fit for a multi-protocol experiment.\n\nCreates a 3-panel figure:\n\nGlobal regression with hyperprior lines\nPer-protocol regression lines\nResidual diagnostics\n\nArguments\n\nresult::RegressionResultMultipleProtocols: Fitted regression result.\nprotein_name::String: Protein name for the plot title.\nx::Array: Reference (bait) protein abundance values (protocols × experiments × replicates).\ny::Array: Prey protein abundance values (protocols × experiments × replicates).\n\nKeywords\n\nnlines::Int=100: Number of posterior regression lines to draw per protocol.\nfile::Union{String, Nothing}=nothing: If provided, save the plot to this path.\n\nReturns\n\nA StatsPlots plot object.\n\n\n\n\n\n","category":"function"},{"location":"visualization/#BayesInteractomics.plot_bayesrange","page":"Visualization","title":"BayesInteractomics.plot_bayesrange","text":"plot_bayesrange(posterior::InferenceResult, prior::InferenceResult, protocol_positions::Vector{I}, protein_name::S; file::Union{S, Nothing} = nothing) where {S<:AbstractString, I<:Int64}\n\nDescription:\n    Plot the Bayes Factor and posterior probability for a given range of log2FC values, a given protein.\n\nArgs:\n  - result::BayesResult:            result object of type BayesResult\n  - protocol_positions<:Vector{I}:  vector of protocol positions to plot\n  - protein_name<:AbstractString:   name of the protein.\n\nKeyword Args:\n  - file<:Union{S, Nothing}:        path to file where figure should be saved\n  - min<:AbstractFloat:             minimum value of log2FC\n  - max<:AbstractFloat:             maximum value of log2FC\n  - stepsize<:AbstractFloat:        stepsize between min and max\n\nReturns:\n  - fig<:Makie.Figure:         figure object\n\n\n\n\n\nplot_bayesrange(result::HBMResult, protocol_positions, protein_name; kwargs...)\n\nPlot Bayes factor as a function of the log₂FC threshold for an HBM result.\n\nComputes and plots how the enrichment Bayes factor changes across a range of threshold values, separately for each protocol and the global estimate.\n\n\n\n\n\nplot_bayesrange(posterior, prior, protocol_positions, protein_name; kwargs...)\n\nPlot Bayes factor range from raw posterior/prior MixtureModel and Normal vectors.\n\nLow-level method that computes Bayes factors across thresholds from the given distributions and delegates to the matrix-based plot_bayesrange method.\n\n\n\n\n\nplot_bayesrange(bf::Matrix, posterior_probs::Matrix, protocol_positions, protein_name; kwargs...)\n\nPlot pre-computed Bayes factor and posterior probability matrices across thresholds.\n\nCreates a two-panel figure: (1) log₁₀ Bayes factor vs. threshold, (2) posterior probability vs. threshold, with one line per protocol.\n\nArguments\n\nbf::Matrix{Float64}: Bayes factors (protocols × thresholds).\nposterior_probs::Matrix{Float64}: Posterior probabilities (protocols × thresholds).\nprotocol_positions::Vector{Int}: Protocol position indices.\nprotein_name::String: Protein name for the plot title.\n\nKeywords\n\nfile::Union{String, Nothing}=nothing: If provided, save the plot to this path.\nmin_value::Float64=-10.0: Minimum threshold value.\nmax_value::Float64=10.0: Maximum threshold value.\nstepsize::Float64=0.1: Threshold step size.\n\n\n\n\n\n","category":"function"},{"location":"network_analysis/#Network-Analysis","page":"Network Analysis","title":"Network Analysis","text":"BayesInteractomics provides comprehensive network analysis capabilities through a package extension that enables visualization and topological analysis of protein interaction networks. This extension automatically loads when you import the required graph packages.","category":"section"},{"location":"network_analysis/#Overview","page":"Network Analysis","title":"Overview","text":"The network analysis extension transforms your Bayesian analysis results into graph structures that can be:\n\nVisualized with customizable layouts and styling\nAnalyzed for topological properties (density, clustering, path lengths)\nSearched for hub proteins using centrality measures\nPartitioned into communities representing protein complexes or functional modules\nExported to standard formats for external tools (Cytoscape, Gephi)","category":"section"},{"location":"network_analysis/#Activation","page":"Network Analysis","title":"Activation","text":"Network analysis features are provided via package extension and require loading the graph packages:\n\nusing BayesInteractomics\nusing Graphs, SimpleWeightedGraphs, GraphPlot, Compose\n\n# Network functions are now available\n\nWithout loading these packages, network functions will throw an error directing you to load the required dependencies.","category":"section"},{"location":"network_analysis/#Quick-Start","page":"Network Analysis","title":"Quick Start","text":"using BayesInteractomics\nusing Graphs, SimpleWeightedGraphs, GraphPlot, Compose\n\n# Run standard Bayesian analysis\ndata = load_data([\"experiment.xlsx\"], sample_cols, control_cols)\nresults = analyse(data, \"H0.xlsx\", refID=1, n_controls=3, n_samples=3)\n\n# Wrap results with bait protein metadata\nar = AnalysisResult(results, bait_protein=\"MYC\", bait_index=1)\n\n# Build high-confidence network\nnet = build_network(ar,\n    posterior_threshold = 0.8,\n    q_threshold = 0.01\n)\n\n# Analyze network properties\nstats = network_statistics(net)\nprintln(\"Network has $(stats.n_nodes) nodes and $(stats.n_edges) edges\")\nprintln(\"Density: $(stats.density)\")\n\n# Find hub proteins\ncm = centrality_measures(net)\ntop_hubs = get_top_hubs(cm, by=:pagerank, n=10)\n\n# Detect protein complexes\ncommunities = detect_communities(net, algorithm=:louvain)\nprintln(\"Found $(communities.n_communities) communities\")\n\n# Visualize\nplot_network(net, layout=:spring, highlight_bait=true)\n\n# Export for Cytoscape\nexport_graphml(net, \"network.graphml\")","category":"section"},{"location":"network_analysis/#Data-Types","page":"Network Analysis","title":"Data Types","text":"","category":"section"},{"location":"network_analysis/#AbstractAnalysisResult","page":"Network Analysis","title":"AbstractAnalysisResult","text":"Base type for analysis results that can be used for network construction. Two implementations are provided:","category":"section"},{"location":"network_analysis/#AnalysisResult","page":"Network Analysis","title":"AnalysisResult","text":"Full analysis result wrapper returned by the analyse() pipeline:\n\nstruct AnalysisResult <: AbstractAnalysisResult\n    results::DataFrame           # Complete analysis results\n    bait_protein::String        # Name of bait protein\n    bait_index::Int            # Index in protein list\n    # ... additional fields from full pipeline\nend","category":"section"},{"location":"network_analysis/#NetworkAnalysisResult","page":"Network Analysis","title":"NetworkAnalysisResult","text":"Lightweight wrapper for custom DataFrames:\n\n# Create from any DataFrame with appropriate columns\ndf = DataFrame(\n    Protein = [\"A\", \"B\", \"C\"],\n    PosteriorProbability = [0.95, 0.85, 0.75],\n    BayesFactor = [100.0, 50.0, 20.0],\n    q_value = [0.001, 0.01, 0.02],\n    mean_log2FC = [3.2, 2.8, 2.1]\n)\n\nar = NetworkAnalysisResult(df, bait_protein=\"MYC\")\nnet = build_network(ar, posterior_threshold=0.8)\n\nRequired DataFrame columns (supports multiple naming conventions):\n\nProtein names: Protein or protein\nPosterior probability: PosteriorProbability, posterior_probability, or posterior_prob\nBayes factor: BayesFactor, bayes_factor, or BF\nQ-value (FDR): q_value, QValue, or q\nLog2 fold change (optional): mean_log2FC or log2FC","category":"section"},{"location":"network_analysis/#InteractionNetwork","page":"Network Analysis","title":"InteractionNetwork","text":"Graph representation of protein interactions:\n\nstruct InteractionNetwork\n    graph::SimpleWeightedDiGraph    # Directed weighted graph\n    protein_names::Vector{String}   # Node labels\n    node_attributes::DataFrame      # Node-level data\n    edge_attributes::DataFrame      # Edge-level data\n    bait_protein::Union{String, Nothing}\n    bait_index::Union{Int, Nothing}\n    threshold_used::NamedTuple     # Filtering thresholds\nend\n\nAccess graph properties:\n\nnv(net.graph)  # Number of nodes\nne(net.graph)  # Number of edges\nnet.protein_names  # Protein names\nnet.node_attributes  # DataFrame with posterior_prob, bayes_factor, etc.","category":"section"},{"location":"network_analysis/#NetworkStatistics","page":"Network Analysis","title":"NetworkStatistics","text":"Topology metrics:\n\nstruct NetworkStatistics\n    n_nodes::Int\n    n_edges::Int\n    density::Float64              # Edges / possible edges\n    avg_degree::Float64           # Average connections per node\n    avg_weighted_degree::Float64  # Average sum of edge weights\n    avg_clustering::Float64       # Clustering coefficient\n    n_components::Int            # Connected components\n    largest_component_size::Int\n    diameter::Union{Int, Nothing}      # Max shortest path (if connected)\n    avg_path_length::Union{Float64, Nothing}  # Average shortest path\nend","category":"section"},{"location":"network_analysis/#CentralityMeasures","page":"Network Analysis","title":"CentralityMeasures","text":"Hub identification scores:\n\nstruct CentralityMeasures\n    protein_names::Vector{String}\n    degree::Vector{Int}              # Number of connections\n    weighted_degree::Vector{Float64} # Sum of edge weights\n    betweenness::Vector{Float64}     # Shortest path centrality\n    closeness::Vector{Float64}       # Inverse average distance\n    eigenvector::Vector{Float64}     # Recursive importance\n    pagerank::Vector{Float64}        # Random walk probability\nend\n\nConvert to DataFrame for easy inspection:\n\ndf = centrality_dataframe(cm)\nsort(df, :PageRank, rev=true)  # Rank by PageRank","category":"section"},{"location":"network_analysis/#CommunityResult","page":"Network Analysis","title":"CommunityResult","text":"Protein complex/module assignments:\n\nstruct CommunityResult\n    protein_names::Vector{String}\n    membership::Vector{Int}      # Community ID for each protein\n    n_communities::Int\n    modularity::Float64         # Quality score (higher is better)\n    community_sizes::Vector{Int}\nend","category":"section"},{"location":"network_analysis/#Network-Construction","page":"Network Analysis","title":"Network Construction","text":"","category":"section"},{"location":"network_analysis/#build_network","page":"Network Analysis","title":"build_network","text":"Build interaction network from analysis results with statistical filtering:\n\nnet = build_network(ar::AbstractAnalysisResult;\n    posterior_threshold = 0.5,\n    bf_threshold = nothing,\n    q_threshold = 0.05,\n    log2fc_threshold = nothing,\n    include_bait = true,\n    weight_by = :posterior_prob\n)\n\nArguments:\n\nposterior_threshold: Minimum posterior probability (default: 0.5)\nbf_threshold: Minimum Bayes factor (optional)\nq_threshold: Maximum FDR q-value (default: 0.05)\nlog2fc_threshold: Minimum absolute log2 fold change (optional)\ninclude_bait: Include bait protein as network node (default: true)\nweight_by: Edge weight source (:posterior_prob, :bayes_factor, or :log2fc)\n\nFiltering strategies:\n\n# High-confidence network (stringent)\nnet_high = build_network(ar,\n    posterior_threshold = 0.9,\n    q_threshold = 0.01,\n    bf_threshold = 10.0\n)\n\n# Medium-confidence network (balanced)\nnet_medium = build_network(ar,\n    posterior_threshold = 0.8,\n    q_threshold = 0.05\n)\n\n# Exploratory network (permissive)\nnet_explore = build_network(ar,\n    posterior_threshold = 0.5,\n    q_threshold = 0.1\n)\n\n# Focus on strong enrichment\nnet_enriched = build_network(ar,\n    posterior_threshold = 0.8,\n    log2fc_threshold = 2.0,\n    weight_by = :log2fc\n)","category":"section"},{"location":"network_analysis/#Network-Statistics","page":"Network Analysis","title":"Network Statistics","text":"","category":"section"},{"location":"network_analysis/#network_statistics","page":"Network Analysis","title":"network_statistics","text":"Compute comprehensive topology metrics:\n\nstats = network_statistics(net)\n\n# Basic properties\nstats.n_nodes              # Number of proteins\nstats.n_edges              # Number of interactions\nstats.density              # 0.0 (sparse) to 1.0 (complete)\n\n# Degree statistics\nstats.avg_degree           # Average connections per node\nstats.avg_weighted_degree  # Average sum of edge weights\n\n# Clustering\nstats.avg_clustering       # Local clustering coefficient\n\n# Connectivity\nstats.n_components         # Number of disconnected subgraphs\nstats.largest_component_size\n\n# Path properties (if connected)\nstats.diameter             # Longest shortest path\nstats.avg_path_length      # Average shortest path\n\nInterpretation:\n\nDensity: Higher values indicate more interconnected proteins (typical PPI networks: 0.01-0.1)\nClustering: Higher values suggest modular organization (protein complexes)\nComponents: Multiple components may indicate distinct functional modules\nDiameter: Network \"width\" - smaller values indicate tighter integration","category":"section"},{"location":"network_analysis/#Centrality-Analysis","page":"Network Analysis","title":"Centrality Analysis","text":"","category":"section"},{"location":"network_analysis/#centrality_measures","page":"Network Analysis","title":"centrality_measures","text":"Identify hub proteins using multiple centrality metrics:\n\ncm = centrality_measures(net)\n\n# Access centrality vectors\ncm.degree          # Simple connection count\ncm.weighted_degree # Weighted connection strength\ncm.betweenness    # Information flow control\ncm.closeness      # Average proximity to all nodes\ncm.eigenvector    # Recursive importance (connected to important nodes)\ncm.pagerank       # Random walk probability (like Google PageRank)\n\nCentrality measure interpretation:\n\nMeasure Identifies Use Case\nDegree Highly connected proteins Core interaction hubs\nWeighted Degree Strong binders High-confidence hubs\nBetweenness Bridge proteins Inter-complex connectors\nCloseness Central proteins Rapid signal propagation\nEigenvector Influential proteins Connected to other hubs\nPageRank Important proteins Overall network importance","category":"section"},{"location":"network_analysis/#get*top*hubs","page":"Network Analysis","title":"gettophubs","text":"Extract top hub proteins by any centrality measure:\n\n# Top 10 proteins by PageRank\ntop_hubs = get_top_hubs(cm, by=:pagerank, n=10)\n\n# Other centrality measures\ntop_by_degree = get_top_hubs(cm, by=:degree, n=10)\ntop_by_betweenness = get_top_hubs(cm, by=:betweenness, n=10)\ntop_by_weighted = get_top_hubs(cm, by=:weighted_degree, n=10)\n\nChoosing centrality measures:\n\nGeneral hub identification: Use PageRank or eigenvector centrality\nDirect interaction partners: Use degree centrality\nFunctional importance: Use betweenness centrality\nHigh-confidence hubs: Use weighted degree with posterior probability weights","category":"section"},{"location":"network_analysis/#centrality_dataframe","page":"Network Analysis","title":"centrality_dataframe","text":"Convert centrality measures to DataFrame for easy analysis:\n\ndf = centrality_dataframe(cm)\n# Returns DataFrame with columns: Protein, Degree, WeightedDegree,\n# Betweenness, Closeness, Eigenvector, PageRank\n\n# Rank proteins by multiple criteria\nsorted = sort(df, [:PageRank, :Degree], rev=true)\n\n# Export to file\nCSV.write(\"hub_proteins.csv\", df)","category":"section"},{"location":"network_analysis/#Community-Detection","page":"Network Analysis","title":"Community Detection","text":"","category":"section"},{"location":"network_analysis/#detect_communities","page":"Network Analysis","title":"detect_communities","text":"Identify protein complexes or functional modules:\n\ncommunities = detect_communities(net, algorithm=:louvain)\n\n# Results\ncommunities.n_communities     # Number of communities found\ncommunities.modularity       # Quality score (higher is better)\ncommunities.community_sizes  # Size of each community\ncommunities.membership       # Community ID for each protein\n\nAvailable algorithms:\n\nAlgorithm Description Best For\n:louvain Modularity optimization Hierarchical communities\n:label_propagation Fast local propagation Large networks\n:greedy_modularity Greedy merging Medium networks\n\nModularity score interpretation:\n\n> 0.3: Strong community structure\n0.1 - 0.3: Moderate community structure\n< 0.1: Weak or no community structure","category":"section"},{"location":"network_analysis/#community_dataframe","page":"Network Analysis","title":"community_dataframe","text":"Convert to DataFrame for analysis:\n\ndf = community_dataframe(communities)\n# Returns DataFrame with columns: Protein, Community\n\n# Analyze community composition\nusing DataFrames\ncombine(groupby(df, :Community), nrow => :Size)","category":"section"},{"location":"network_analysis/#get*community*proteins","page":"Network Analysis","title":"getcommunityproteins","text":"Extract proteins from specific community:\n\n# Get all proteins in community 1\nproteins = get_community_proteins(communities, 1)\n\n# Analyze each community\nfor i in 1:communities.n_communities\n    proteins = get_community_proteins(communities, i)\n    println(\"Community $i has $(length(proteins)) proteins:\")\n    println(join(proteins, \", \"))\nend\n\nBiological interpretation:\n\nEach community may represent a protein complex or functional module\nLarge communities (>20 proteins) may contain multiple sub-complexes\nSmall communities (<5 proteins) may be transient interactions\nCompare with known protein complexes (CORUM, ComplexPortal databases)","category":"section"},{"location":"network_analysis/#Visualization","page":"Network Analysis","title":"Visualization","text":"","category":"section"},{"location":"network_analysis/#plot_network","page":"Network Analysis","title":"plot_network","text":"Create customizable network visualizations:\n\nplot_network(net;\n    layout = :spring,\n    node_size = :degree,\n    node_color = :posterior_prob,\n    edge_width = :weight,\n    show_labels = true,\n    highlight_bait = true,\n    figsize = (800, 800)\n)\n\nLayout algorithms:\n\n:spring: Force-directed layout (good for most networks)\n:circular: Nodes arranged in circle (good for small networks)\n:shell: Shell layout with multiple levels\n:spectral: Spectral decomposition layout\n\nNode size options:\n\n:degree: Size by number of connections\n:posterior_prob: Size by posterior probability\n:log2fc: Size by fold change magnitude\n:uniform: All nodes same size\n\nNode color options:\n\n:posterior_prob: Blue (low) to red (high) gradient\n:log2fc: Diverging blue (down) to red (up) scale\n:community: Different color per community (requires running detect_communities first)\n:uniform: Single color (steel blue)\n\nEdge width options:\n\n:weight: Width proportional to edge weight\n:uniform: All edges same width\n\nExamples:\n\n# Basic visualization\nplot_network(net)\n\n# Highlight bait and show posterior probabilities\nplot_network(net,\n    layout = :spring,\n    node_color = :posterior_prob,\n    node_size = :degree,\n    highlight_bait = true\n)\n\n# Focus on fold change\nplot_network(net,\n    node_color = :log2fc,\n    node_size = :log2fc,\n    edge_width = :uniform\n)\n\n# Clean circular layout for presentation\nplot_network(net,\n    layout = :circular,\n    node_color = :uniform,\n    show_labels = false,\n    figsize = (1200, 1200)\n)","category":"section"},{"location":"network_analysis/#save*network*plot","page":"Network Analysis","title":"savenetworkplot","text":"Save visualizations to file:\n\nsave_network_plot(net, \"network.png\")\n\n# Supported formats\nsave_network_plot(net, \"network.png\", figsize=(1200, 1200))\nsave_network_plot(net, \"network.pdf\")  # Vector format for publications\nsave_network_plot(net, \"network.svg\")  # Vector format for web\n\n# With custom styling\nsave_network_plot(net, \"network.png\",\n    layout = :spring,\n    node_color = :posterior_prob,\n    highlight_bait = true,\n    figsize = (2400, 2400)  # High resolution\n)\n\nFile format recommendations:\n\nPNG: Presentations, quick viewing (specify high figsize for print quality)\nPDF: Publications, LaTeX documents (vector graphics, scalable)\nSVG: Web, interactive applications (vector graphics, editable)","category":"section"},{"location":"network_analysis/#Export","page":"Network Analysis","title":"Export","text":"","category":"section"},{"location":"network_analysis/#export_graphml","page":"Network Analysis","title":"export_graphml","text":"Export to GraphML format for Cytoscape, Gephi, and other network tools:\n\nexport_graphml(net, \"network.graphml\")\n\nGraphML preserves all node and edge attributes:\n\nNode attributes: protein name, posterior probability, Bayes factor, q-value, log2FC, bait status\nEdge attributes: interaction weight\n\nUsing in Cytoscape:\n\nOpen Cytoscape\nFile → Import → Network from File\nSelect the .graphml file\nAttributes are imported as node/edge columns\nUse Style panel to map attributes to visual properties\n\nUsing in Gephi:\n\nOpen Gephi\nFile → Open → Select .graphml file\nImport as \"Directed graph\"\nAttributes available in Data Laboratory","category":"section"},{"location":"network_analysis/#export_edgelist","page":"Network Analysis","title":"export_edgelist","text":"Export edge list as CSV:\n\nexport_edgelist(net, \"edges.csv\")\n\n# Without additional attributes\nexport_edgelist(net, \"edges.csv\", include_attributes=false)\n\nCreates CSV with columns:\n\nsource: Source protein name\ntarget: Target protein name\nweight: Edge weight\nAdditional edge attributes (if include_attributes=true)\n\nUse cases:\n\nImport into R/Python for custom analysis\nNetwork construction in other tools\nSimple tabular view of interactions","category":"section"},{"location":"network_analysis/#export*node*attributes","page":"Network Analysis","title":"exportnodeattributes","text":"Export node attributes as CSV:\n\nexport_node_attributes(net, \"nodes.csv\")\n\nCreates CSV with columns:\n\nprotein: Protein name\nnode_id: Node index\nposterior_prob: Posterior probability\nbayes_factor: Bayes factor\nq_value: FDR q-value\nmean_log2fc: Mean log2 fold change (if available)\nis_bait: Boolean indicating bait protein\n\nUse cases:\n\nStatistical analysis in R/Python\nAnnotation with external databases\nCustom plotting","category":"section"},{"location":"network_analysis/#export*network*bundle","page":"Network Analysis","title":"exportnetworkbundle","text":"Export all formats at once:\n\nexport_network_bundle(net, \"results/mynetwork\")\n# Creates:\n#   results/mynetwork.graphml\n#   results/mynetwork_edges.csv\n#   results/mynetwork_nodes.csv","category":"section"},{"location":"network_analysis/#Complete-Workflow-Example","page":"Network Analysis","title":"Complete Workflow Example","text":"Here's a complete workflow from data loading to network export:\n\nusing BayesInteractomics\nusing Graphs, SimpleWeightedGraphs, GraphPlot, Compose\nusing DataFrames, CSV\n\n# 1. Load and analyze data\nprintln(\"Loading data...\")\ndata = load_data(\n    [\"experiment.xlsx\"],\n    Dict(1 => [5,6,7]),  # sample columns\n    Dict(1 => [2,3,4])   # control columns\n)\n\nprintln(\"Running Bayesian analysis...\")\nresults = analyse(data, \"copula_H0.xlsx\",\n    refID = 1,\n    n_controls = 3,\n    n_samples = 3\n)\n\n# 2. Wrap results\nar = AnalysisResult(results, bait_protein=\"MYC\", bait_index=1)\n\n# 3. Build high-confidence network\nprintln(\"Building network...\")\nnet = build_network(ar,\n    posterior_threshold = 0.8,\n    q_threshold = 0.01,\n    weight_by = :posterior_prob\n)\n\n# 4. Analyze network topology\nprintln(\"\\n=== Network Statistics ===\")\nstats = network_statistics(net)\nprintln(\"Nodes: $(stats.n_nodes)\")\nprintln(\"Edges: $(stats.n_edges)\")\nprintln(\"Density: $(round(stats.density, digits=4))\")\nprintln(\"Avg clustering: $(round(stats.avg_clustering, digits=4))\")\nprintln(\"Components: $(stats.n_components)\")\n\n# 5. Identify hub proteins\nprintln(\"\\n=== Top Hub Proteins ===\")\ncm = centrality_measures(net)\ntop10 = get_top_hubs(cm, by=:pagerank, n=10)\nprintln(top10)\n\n# Save centrality analysis\nCSV.write(\"hub_analysis.csv\", centrality_dataframe(cm))\n\n# 6. Detect protein complexes\nprintln(\"\\n=== Community Detection ===\")\ncommunities = detect_communities(net, algorithm=:louvain)\nprintln(\"Found $(communities.n_communities) communities\")\nprintln(\"Modularity: $(round(communities.modularity, digits=4))\")\nprintln(\"Sizes: $(communities.community_sizes)\")\n\n# Save community assignments\nCSV.write(\"communities.csv\", community_dataframe(communities))\n\n# Print each community\nfor i in 1:communities.n_communities\n    proteins = get_community_proteins(communities, i)\n    println(\"\\nCommunity $i ($(length(proteins)) proteins):\")\n    println(\"  \", join(proteins[1:min(5, length(proteins))], \", \"),\n            length(proteins) > 5 ? \"...\" : \"\")\nend\n\n# 7. Visualize\nprintln(\"\\n=== Creating Visualizations ===\")\nsave_network_plot(net, \"network_overview.png\",\n    layout = :spring,\n    node_color = :posterior_prob,\n    node_size = :degree,\n    highlight_bait = true,\n    figsize = (1200, 1200)\n)\n\nsave_network_plot(net, \"network_publication.pdf\",\n    layout = :spring,\n    show_labels = true,\n    figsize = (800, 800)\n)\n\n# 8. Export for external tools\nprintln(\"\\n=== Exporting Results ===\")\nexport_network_bundle(net, \"results/myc_network\")\n\nprintln(\"\\n✓ Analysis complete!\")\nprintln(\"  Network plots: network_overview.png, network_publication.pdf\")\nprintln(\"  Hub analysis: hub_analysis.csv\")\nprintln(\"  Communities: communities.csv\")\nprintln(\"  Export bundle: results/myc_network.*\")","category":"section"},{"location":"network_analysis/#Advanced-Topics","page":"Network Analysis","title":"Advanced Topics","text":"","category":"section"},{"location":"network_analysis/#Custom-Network-Construction","page":"Network Analysis","title":"Custom Network Construction","text":"For specialized analyses, you can build networks directly from any DataFrame:\n\n# Load your own interaction scores\ndf = CSV.read(\"my_interactions.csv\", DataFrame)\n\n# Must have these columns (or variants):\n# - Protein (or protein)\n# - PosteriorProbability (or posterior_probability, posterior_prob)\n# - BayesFactor (or bayes_factor, BF)\n# - q_value (or QValue, q)\n\n# Create analysis result wrapper\nar = NetworkAnalysisResult(df, bait_protein=\"MYC\")\n\n# Build network\nnet = build_network(ar, posterior_threshold=0.8)","category":"section"},{"location":"network_analysis/#Combining-Multiple-Networks","page":"Network Analysis","title":"Combining Multiple Networks","text":"Compare networks across conditions:\n\n# Build networks for different conditions\nnet_control = build_network(results_control, posterior_threshold=0.8)\nnet_treatment = build_network(results_treatment, posterior_threshold=0.8)\n\n# Compare statistics\nstats_control = network_statistics(net_control)\nstats_treatment = network_statistics(net_treatment)\n\nprintln(\"Control: $(stats_control.n_edges) edges\")\nprintln(\"Treatment: $(stats_treatment.n_edges) edges\")\n\n# Identify condition-specific hubs\ncm_control = centrality_measures(net_control)\ncm_treatment = centrality_measures(net_treatment)\n\nhubs_control = get_top_hubs(cm_control, n=20)\nhubs_treatment = get_top_hubs(cm_treatment, n=20)\n\n# Find condition-specific hubs\ncontrol_specific = setdiff(hubs_control.Protein, hubs_treatment.Protein)\ntreatment_specific = setdiff(hubs_treatment.Protein, hubs_control.Protein)","category":"section"},{"location":"network_analysis/#Subnetwork-Extraction","page":"Network Analysis","title":"Subnetwork Extraction","text":"Extract subnetworks for focused analysis:\n\n# Get proteins in largest community\ncommunities = detect_communities(net)\nlargest_comm = argmax(communities.community_sizes)\ncomm_proteins = get_community_proteins(communities, largest_comm)\n\n# Filter results DataFrame\nsubset_results = filter(row -> row.Protein in comm_proteins, ar.results)\n\n# Build subnetwork\nar_subset = NetworkAnalysisResult(subset_results, bait_protein=ar.bait_protein)\nsubnet = build_network(ar_subset, posterior_threshold=0.5)\n\n# Analyze subnetwork\nplot_network(subnet, layout=:circular)","category":"section"},{"location":"network_analysis/#Integration-with-External-Data","page":"Network Analysis","title":"Integration with External Data","text":"Enrich network with external annotations:\n\n# Load GO terms, pathways, etc.\nannotations = CSV.read(\"protein_annotations.csv\", DataFrame)\n\n# Join with node attributes\nenriched_nodes = leftjoin(net.node_attributes, annotations, on=:protein)\n\n# Analyze enrichment\nfor comm_id in 1:communities.n_communities\n    proteins = get_community_proteins(communities, comm_id)\n    comm_annotations = filter(row -> row.protein in proteins, enriched_nodes)\n\n    # Count GO terms, pathways, etc.\n    println(\"Community $comm_id enriched terms:\")\n    println(combine(groupby(comm_annotations, :GO_term), nrow => :count))\nend","category":"section"},{"location":"network_analysis/#Best-Practices","page":"Network Analysis","title":"Best Practices","text":"","category":"section"},{"location":"network_analysis/#Threshold-Selection","page":"Network Analysis","title":"Threshold Selection","text":"Stringent (high confidence):\n\nnet = build_network(ar,\n    posterior_threshold = 0.9,\n    q_threshold = 0.01,\n    bf_threshold = 10.0\n)\n\nUse for: Core interactome, publication figures, high-confidence candidates\n\nModerate (balanced):\n\nnet = build_network(ar,\n    posterior_threshold = 0.8,\n    q_threshold = 0.05\n)\n\nUse for: General analysis, community detection, hub identification\n\nPermissive (exploratory):\n\nnet = build_network(ar,\n    posterior_threshold = 0.5,\n    q_threshold = 0.1\n)\n\nUse for: Discovery, pathway analysis, network topology studies","category":"section"},{"location":"network_analysis/#Visualization-Guidelines","page":"Network Analysis","title":"Visualization Guidelines","text":"For presentations:\nUse high-resolution PNG (figsize ≥ 1200×1200)\nHighlight bait protein\nColor by posterior probability\nSize by degree centrality\nFor publications:\nExport as PDF or SVG (vector graphics)\nConsider circular layout for clarity\nUse uniform or subtle colors\nShow labels for key proteins only\nFor exploration:\nUse spring layout for natural clustering\nColor by communities or functional annotations\nSize by relevance metric (degree, PageRank)\nExport to Cytoscape for interactive exploration","category":"section"},{"location":"network_analysis/#Performance-Considerations","page":"Network Analysis","title":"Performance Considerations","text":"Large networks (>500 nodes): Use layout=:circular instead of :spring for faster rendering\nMany communities: Use :louvain algorithm (faster than :greedy_modularity)\nRepeated analysis: Cache build_network results to avoid recomputation\nExport large networks to Cytoscape for better performance","category":"section"},{"location":"network_analysis/#Troubleshooting","page":"Network Analysis","title":"Troubleshooting","text":"","category":"section"},{"location":"network_analysis/#\"Network-extension-not-loaded\"-error","page":"Network Analysis","title":"\"Network extension not loaded\" error","text":"Problem: Network functions not available\n\nSolution:\n\nusing Graphs, SimpleWeightedGraphs, GraphPlot, Compose","category":"section"},{"location":"network_analysis/#Empty-network-warning","page":"Network Analysis","title":"Empty network warning","text":"Problem: No interactions pass filtering criteria\n\nSolution: Relax thresholds\n\nnet = build_network(ar, posterior_threshold=0.5, q_threshold=0.1)","category":"section"},{"location":"network_analysis/#Disconnected-network-(diameter-nothing)","page":"Network Analysis","title":"Disconnected network (diameter = nothing)","text":"Problem: Network has multiple components\n\nInterpretation: Normal for interaction networks; indicates distinct functional modules\n\nAnalysis:\n\nstats = network_statistics(net)\nprintln(\"Components: $(stats.n_components)\")\nprintln(\"Largest component: $(stats.largest_component_size)\")","category":"section"},{"location":"network_analysis/#Community-detection-yields-single-community","page":"Network Analysis","title":"Community detection yields single community","text":"Problem: Low modularity, all proteins in one community\n\nCauses:\n\nStar topology (all proteins connected to bait)\nToo few edges\nVery dense network\n\nSolutions:\n\nTry different algorithm\nRelax filtering thresholds to include more edges\nConsider hierarchical clustering for star networks","category":"section"},{"location":"network_analysis/#References","page":"Network Analysis","title":"References","text":"For more information on the statistical methods:\n\nSee Model Evaluation for Bayesian analysis details\nSee Examples for complete workflows\nSee API Reference for function signatures","category":"section"},{"location":"network_analysis/#Network-Analysis-Literature","page":"Network Analysis","title":"Network Analysis Literature","text":"Modularity: Newman, M. E. J. (2006). Modularity and community structure in networks. PNAS, 103(23), 8577-8582.\nCentrality measures: Freeman, L. C. (1977). A set of measures of centrality based on betweenness. Sociometry, 40(1), 35-41.\nPageRank: Brin, S., & Page, L. (1998). The anatomy of a large-scale hypertextual web search engine. Computer Networks, 30(1-7), 107-117.\nCommunity detection: Blondel, V. D., et al. (2008). Fast unfolding of communities in large networks. Journal of Statistical Mechanics, 2008(10), P10008.","category":"section"},{"location":"reports/#Interactive-HTML-Reports","page":"Reports","title":"Interactive HTML Reports","text":"","category":"section"},{"location":"reports/#Overview","page":"Reports","title":"Overview","text":"BayesInteractomics can generate self-contained, interactive HTML reports that combine results tables, diagnostic plots, and analysis metadata into a single file for easy sharing and review.\n\nTwo report types are available:\n\nStandard analysis report: Summary of a single run_analysis run\nDifferential analysis report: Summary of a differential_analysis comparison","category":"section"},{"location":"reports/#Standard-Analysis-Report","page":"Reports","title":"Standard Analysis Report","text":"Generated automatically when generate_report_html = true in CONFIG (default):\n\nconfig = CONFIG(\n    # ... analysis parameters ...\n    generate_report_html = true,\n    output = OutputFiles(\"/path/to/results\")\n)\n\nfinal_df, result = run_analysis(config)\n# Report saved to config.output.report_file (default: interactive_report.html)","category":"section"},{"location":"reports/#Manual-Generation","page":"Reports","title":"Manual Generation","text":"generate_report(final_results_df, config)\n\n# Custom output path\ngenerate_report(final_results_df, config, output = \"my_report.html\")","category":"section"},{"location":"reports/#Report-Contents","page":"Reports","title":"Report Contents","text":"The standard report includes:\n\nResults table: Sortable, filterable table of all proteins with posterior probabilities, Bayes factors, q-values, and log₂FC values\nVolcano plot: Interactive version with hover information\nConvergence plot: EM algorithm convergence diagnostics\nEvidence plot: Distribution of individual and combined Bayes factors\nMethods section: Auto-generated description of the statistical methods used\nDiagnostic flags: Per-protein quality indicators (when diagnostics are enabled)\nSensitivity metrics: Prior sensitivity ranges (when sensitivity analysis is enabled)","category":"section"},{"location":"reports/#Differential-Analysis-Report","page":"Reports","title":"Differential Analysis Report","text":"Generated automatically by the differential_analysis pipeline when generate_report_html = true in DifferentialConfig:\n\ndiff = differential_analysis(config_A, config_B,\n    condition_A = \"WT\",\n    condition_B = \"Mutant\",\n    config = DifferentialConfig(generate_report_html = true)\n)","category":"section"},{"location":"reports/#Manual-Generation-2","page":"Reports","title":"Manual Generation","text":"generate_differential_report(diff)\n\n# Custom output path\ngenerate_differential_report(diff, output = \"diff_report.html\")","category":"section"},{"location":"reports/#Report-Contents-2","page":"Reports","title":"Report Contents","text":"The differential report includes:\n\nDifferential results table: All proteins with dBF, Δlog₂FC, classifications\nVolcano plot: Differential Bayes factors vs. significance\nEvidence plot: Per-evidence-type differential Bayes factors\nClassification summary: Bar chart of gained/lost/unchanged interactions\nCondition comparison: Side-by-side scatter plots","category":"section"},{"location":"reports/#Customization","page":"Reports","title":"Customization","text":"Reports are generated as self-contained HTML files with embedded CSS and JavaScript. Table filtering and plot-selection synchronization are built in.","category":"section"},{"location":"reports/#Output-Paths","page":"Reports","title":"Output Paths","text":"Output paths are controlled through the OutputFiles struct:\n\noutput = OutputFiles(\"/path/to/results\")\noutput.report_file          # Standard report path\noutput.report_methods_file  # Methods markdown path","category":"section"},{"location":"reports/#API-Reference","page":"Reports","title":"API Reference","text":"","category":"section"},{"location":"reports/#BayesInteractomics.generate_report","page":"Reports","title":"BayesInteractomics.generate_report","text":"generate_report(results::DataFrame, config::CONFIG; output=config.output.report_file)\n\nGenerate a self-contained interactive HTML report from analysis results.\n\nThe report includes:\n\nInteractive volcano plot and rank-rank plot (Plotly.js, CDN)\nSearchable/filterable results table (DataTables.js, CDN)\nStatic PNG embeds for evidence, diagnostic, and sensitivity plots\nAuto-generated methods section text\nReproducibility metadata\n\nThe generated HTML file can be opened in any modern browser without any additional software installation.\n\nArguments\n\nresults::DataFrame: Final results DataFrame from run_analysis().\nconfig::CONFIG: Analysis configuration (used for parameters and file paths).\n\nKeywords\n\noutput::String: Path for the generated HTML file. Defaults to config.output.report_file.\n\nExample\n\nresults, ar = run_analysis(config)\ngenerate_report(results, config)\n\n\n\n\n\n","category":"function"},{"location":"reports/#BayesInteractomics.generate_differential_report","page":"Reports","title":"BayesInteractomics.generate_differential_report","text":"generate_differential_report(diff::DifferentialResult; output)\n\nGenerate a self-contained interactive HTML report for a differential interaction analysis.\n\nThe report includes:\n\nDashboard summary (N gained / lost / unchanged / condition-specific)\nInteractive Plotly differential volcano plot (Δlog₂FC vs log₁₀(dBF), coloured by classification)\nSearchable/filterable DataTables results table\nStatic PNG / SVG embeds for all existing differential plots\nAnalysis metadata\n\nArguments\n\ndiff::DifferentialResult: Output from differential_analysis().\n\nKeywords\n\noutput::String: Path for the HTML file. Defaults to replacing the results file extension with _report.html.\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/#Diagnostics-and-Model-Validation","page":"Diagnostics","title":"Diagnostics and Model Validation","text":"","category":"section"},{"location":"diagnostics/#Overview","page":"Diagnostics","title":"Overview","text":"BayesInteractomics provides a comprehensive diagnostics toolkit to validate the statistical models and assess result reliability. The diagnostics module includes:\n\nPosterior Predictive Checks (PPC): Simulate data from fitted models and compare to observations\nResidual Analysis: Detect model misspecification through standardized residuals\nCalibration Assessment: Verify that predicted probabilities match empirical discovery rates\nPrior Sensitivity Analysis: Evaluate how robust results are to prior choices\n\nAll diagnostics can be run automatically via the run_analysis pipeline by setting run_diagnostics=true and run_sensitivity=true in the CONFIG struct.","category":"section"},{"location":"diagnostics/#Quick-Start","page":"Diagnostics","title":"Quick Start","text":"using BayesInteractomics\n\nconfig = CONFIG(\n    datafile = [\"data.xlsx\"],\n    control_cols = [Dict(1 => [2,3,4])],\n    sample_cols = [Dict(1 => [5,6,7])],\n    poi = \"BAIT\",\n    refID = 1,\n    n_controls = 3,\n    n_samples = 3,\n    # Enable diagnostics\n    run_diagnostics = true,\n    run_sensitivity = true,\n    diagnostics_config = DiagnosticsConfig(\n        n_proteins_to_check = 50,\n        n_ppc_draws = 500\n    )\n)\n\nfinal_df, result = run_analysis(config)\n\nWhen enabled, diagnostic flags and sensitivity metrics are automatically merged into the final results DataFrame.","category":"section"},{"location":"diagnostics/#Posterior-Predictive-Checks","page":"Diagnostics","title":"Posterior Predictive Checks","text":"PPC validates model fit by re-running inference for a subset of proteins and comparing simulated data to the observations.","category":"section"},{"location":"diagnostics/#How-It-Works","page":"Diagnostics","title":"How It Works","text":"Select proteins for checking (stratified by posterior probability)\nRe-run Bayesian inference for each selected protein\nDraw posterior predictive samples from the fitted model\nCompare simulated data statistics to observed data","category":"section"},{"location":"diagnostics/#Configuration","page":"Diagnostics","title":"Configuration","text":"DiagnosticsConfig(\n    n_proteins_to_check = 50,    # Number of proteins to check\n    n_ppc_draws = 500,           # Posterior predictive draws per protein\n    seed = 42,                   # RNG seed for reproducibility\n    protein_selection = :stratified,  # :stratified, :random, or :top\n    residual_model = :both,      # :hbm, :regression, or :both\n    calibration_bins = 10        # Number of bins for calibration plot\n)","category":"section"},{"location":"diagnostics/#PPC-Plots","page":"Diagnostics","title":"PPC Plots","text":"# After running diagnostics through run_analysis, plots are saved automatically.\n# Manual usage:\nppc_density_plot(ppc_result)         # Observed vs. predicted density\nppc_pvalue_histogram(diagnostics)    # Distribution of PPC p-values\nbb_ppc_summary_plot(bb_ppcs)         # Beta-Bernoulli PPC summary\n\nA well-calibrated model produces a uniform distribution of PPC p-values.","category":"section"},{"location":"diagnostics/#Residual-Analysis","page":"Diagnostics","title":"Residual Analysis","text":"Standardized residuals reveal systematic deviations between model predictions and data.","category":"section"},{"location":"diagnostics/#Available-Diagnostics","page":"Diagnostics","title":"Available Diagnostics","text":"# Q-Q plot: residuals should follow a standard normal distribution\nresidual_qq_plot(residual_result)\n\n# Scale-location plot: detect heteroscedasticity\nscale_location_plot(residual_result)\n\n# Distribution plot: inspect residual shape\nresidual_distribution_plot(residual_result)","category":"section"},{"location":"diagnostics/#Interpretation","page":"Diagnostics","title":"Interpretation","text":"Q-Q plot: Points on the diagonal indicate well-behaved residuals\nScale-location plot: A flat trend indicates constant variance (homoscedasticity)\nHeavy tails in Q-Q plot: Consider using robust regression (regression_likelihood = :robust_t)","category":"section"},{"location":"diagnostics/#Calibration-Assessment","page":"Diagnostics","title":"Calibration Assessment","text":"Calibration plots verify whether predicted posterior probabilities match empirical discovery rates.\n\n# Standard calibration (all 3 BFs > 1.0 as positive criterion)\ncalibration_plot(calibration_result)\n\n# Compare strict vs. relaxed calibration criteria\ncalibration_comparison_plot(diagnostics_result)","category":"section"},{"location":"diagnostics/#Calibration-Criteria","page":"Diagnostics","title":"Calibration Criteria","text":"Three calibration strategies are computed automatically:\n\nStrategy Positive criterion Use case\nStrict All 3 BFs > 1.0 Conservative, low false positives\nRelaxed ≥2 of 3 BFs > 1.0 Moderate, handles noisy evidence\nEnrichment-only BF_enrichment > 3.0 When detection/correlation are unreliable\n\nPerfect calibration means the points lie on the diagonal.","category":"section"},{"location":"diagnostics/#Prior-Sensitivity-Analysis","page":"Diagnostics","title":"Prior Sensitivity Analysis","text":"Evaluates how robust posterior probabilities are to different prior specifications.","category":"section"},{"location":"diagnostics/#Configuration-2","page":"Diagnostics","title":"Configuration","text":"SensitivityConfig(\n    # Beta-Bernoulli prior grids\n    bb_alpha_grid = [0.5, 1.0, 2.0, 5.0],\n    bb_beta_grid = [0.5, 1.0, 2.0, 5.0],\n    # EM prior grids\n    em_prior_settings = [\n        :default, :permissive, :stringent,\n        (α = 10.0, β = 190.0),\n        (α = 50.0, β = 100.0)\n    ]\n)","category":"section"},{"location":"diagnostics/#Sensitivity-Plots","page":"Diagnostics","title":"Sensitivity Plots","text":"# Tornado plot: which prior has the largest impact?\nsensitivity_tornado_plot(sensitivity_result, n_top = 20)\n\n# Heatmap: posterior probability across prior settings\nsensitivity_heatmap(sensitivity_result, n_top = 20)\n\n# Rank correlation: do rankings change with different priors?\nsensitivity_rank_correlation(sensitivity_result)","category":"section"},{"location":"diagnostics/#Interpretation-2","page":"Diagnostics","title":"Interpretation","text":"Low sensitivity (range < 0.1): Results are robust; prior choice does not matter\nModerate sensitivity (range 0.1–0.3): Inspect individual proteins; borderline calls may change\nHigh sensitivity (range > 0.3): Consider collecting more data or using a more conservative threshold\n\nPer-protein sensitivity metrics (std, min, max, range) are merged into final_results.xlsx when both run_diagnostics and run_sensitivity are enabled.","category":"section"},{"location":"diagnostics/#Model-Comparison-(WAIC)","page":"Diagnostics","title":"Model Comparison (WAIC)","text":"When run_model_comparison = true (default), BayesInteractomics fits both Normal and robust (Student-t) regression models and compares them via the Widely Applicable Information Criterion (WAIC).\n\nconfig = CONFIG(\n    # ...\n    run_model_comparison = true,\n    regression_likelihood = :robust_t,\n    student_t_nu = 5.0,\n    optimize_nu = true    # Optimize ν via Brent's method\n)","category":"section"},{"location":"diagnostics/#ν-Optimization","page":"Diagnostics","title":"ν Optimization","text":"When optimize_nu = true, the degrees-of-freedom parameter ν is optimized over [3, 50] by minimizing WAIC. The result is shown in a diagnostic plot:\n\nnu_optimization_plot(nu_result)","category":"section"},{"location":"diagnostics/#Diagnostic-Flags","page":"Diagnostics","title":"Diagnostic Flags","text":"The diagnostics pipeline computes per-protein flags that are merged into the results:\n\nFlag Meaning\nlow_data Fewer than 3 non-missing observations\nresidual_outlier Standardized residual > 3 in magnitude\nppc_fail_hbm HBM PPC p-value < 0.05\nppc_fail_regression Regression PPC p-value < 0.05\nhigh_sensitivity Posterior range across priors > 0.3\n\nThese flags help identify proteins whose results should be interpreted with caution.","category":"section"},{"location":"diagnostics/#API-Reference","page":"Diagnostics","title":"API Reference","text":"","category":"section"},{"location":"diagnostics/#Diagnostic-Plots","page":"Diagnostics","title":"Diagnostic Plots","text":"","category":"section"},{"location":"diagnostics/#BayesInteractomics.model_diagnostics","page":"Diagnostics","title":"BayesInteractomics.model_diagnostics","text":"model_diagnostics(ar, data::InteractionData; kwargs...) -> DiagnosticsResult\n\nRun posterior predictive checks (PPC) and model diagnostics on analysis results.\n\nRe-runs inference for a subset of proteins to generate posterior predictive samples, computes standardized residuals, and assesses calibration consistency.\n\nArguments\n\nar: Completed AnalysisResult from run_analysis()\ndata::InteractionData: Raw data used in the analysis\n\nKeywords\n\nconfig::DiagnosticsConfig: Diagnostics configuration (default: DiagnosticsConfig())\nn_controls::Int: Number of control replicates\nn_samples::Int: Number of sample replicates\nrefID::Int: Bait protein index\nverbose::Bool: Print progress info\n\nReturns\n\nDiagnosticsResult with PPC results, residuals, calibration, and summary\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/#BayesInteractomics.sensitivity_analysis","page":"Diagnostics","title":"BayesInteractomics.sensitivity_analysis","text":"sensitivity_analysis(ar, data::InteractionData; kwargs...) -> SensitivityResult\n\nRun prior sensitivity analysis by sweeping Beta-Bernoulli detection priors and evidence combination priors (copula-EM or latent class), then summarizing how posterior probabilities change across the grid.\n\nHBM/regression priors are excluded because they are data-driven (fitted via τ0()/μ0()).\n\nArguments\n\nar: Completed analysis result (AnalysisResult), provides baseline BFs and combination method\ndata::InteractionData: Raw data (needed for BB recomputation)\n\nKeywords\n\nconfig::SensitivityConfig: Grid specification (default: SensitivityConfig())\nn_controls::Int: Number of control replicates\nn_samples::Int: Number of sample replicates\nrefID::Int: Bait protein index\nH0_file::String: Path to H0 file for copula mode\ncombination_method::Symbol: :copula or :latent_class\nlc_n_iterations::Int: VMP iterations for latent class\nlc_convergence_tol::Float64: Convergence tolerance for latent class\nverbose::Bool: Print progress info\n\nReturns\n\nSensitivityResult with posterior/BF/q matrices and summary statistics\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/#BayesInteractomics.DiagnosticsConfig","page":"Diagnostics","title":"BayesInteractomics.DiagnosticsConfig","text":"DiagnosticsConfig\n\nConfiguration for posterior predictive checks and model diagnostics.\n\nFields\n\nn_ppc_draws::Int: Number of posterior predictive draws per protein (default: 1000)\nn_proteins_to_check::Int: Number of proteins to run PPC on (default: 50)\nppc_protein_selection::Symbol: Strategy for selecting proteins — :top_and_random selects top N/2 by combined BF plus N/2 random (default: :top_and_random)\nresidual_model::Symbol: Which model residuals to compute — :both, :hbm, or :regression (default: :both)\ncalibration_bins::Int: Number of bins for calibration assessment (default: 10)\nn_top_display::Int: Number of top proteins to show in reports (default: 20)\nseed::Int: Random seed for reproducibility (default: 42)\n\n\n\n\n\n","category":"type"},{"location":"diagnostics/#BayesInteractomics.SensitivityConfig","page":"Diagnostics","title":"BayesInteractomics.SensitivityConfig","text":"SensitivityConfig\n\nConfiguration for prior sensitivity analysis sweeps.\n\nFields\n\nbb_priors: Grid of (α, β) pairs for Beta-Bernoulli prior sweep\nem_prior_grid: Grid of (α, β) NamedTuples for copula-EM prior sweep\nlc_alpha_prior_grid: Grid of Dirichlet alpha vectors for latent class prior sweep\nn_top_proteins: Number of top proteins to highlight in reports\n\n\n\n\n\n","category":"type"},{"location":"diagnostics/#BayesInteractomics.SensitivityResult","page":"Diagnostics","title":"BayesInteractomics.SensitivityResult","text":"SensitivityResult\n\nComplete results from a prior sensitivity analysis sweep.\n\nFields\n\nconfig: The SensitivityConfig used for the sweep\nprior_settings: Vector of PriorSetting describing each column of the matrices\nposterior_matrix: Matrix of posterior probabilities (nproteins × nsettings)\nbf_matrix: Matrix of combined Bayes factors (nproteins × nsettings)\nq_matrix: Matrix of q-values (nproteins × nsettings)\nprotein_names: Vector of protein identifiers\nbaseline_index: Column index of the baseline (default) prior setting\nsummary: Per-protein summary statistics across all settings\nclassification_stability: Per-protein classification stability across thresholds\ntimestamp: When the analysis was run\n\n\n\n\n\n","category":"type"},{"location":"diagnostics/#BayesInteractomics.CalibrationResult","page":"Diagnostics","title":"BayesInteractomics.CalibrationResult","text":"CalibrationResult\n\nCalibration assessment comparing predicted posterior probabilities to observed agreement rates.\n\nNote: Without a gold standard, \"observed truth\" is defined as internal consistency — a protein is empirically positive if all three individual Bayes factors (enrichment, correlation, detection) exceed 1.0. This is a self-consistency check, not true calibration.\n\nFields\n\nbin_midpoints::Vector{Float64}: Midpoint of each probability bin\npredicted_rate::Vector{Float64}: Mean predicted posterior in each bin\nobserved_rate::Vector{Float64}: Fraction of empirically positive proteins in each bin\nbin_counts::Vector{Int}: Number of proteins in each bin\nece::Float64: Expected Calibration Error (weighted mean |predicted - observed|)\nmce::Float64: Maximum Calibration Error (max |predicted - observed|)\n\n\n\n\n\n","category":"type"},{"location":"diagnostics/#BayesInteractomics.ResidualResult","page":"Diagnostics","title":"BayesInteractomics.ResidualResult","text":"ResidualResult\n\nStandardized residuals from HBM or regression model across all proteins.\n\nFields\n\nmodel::Symbol: Which model produced these residuals (:hbm or :regression)\nprotein_names::Vector{String}: Protein identifiers\nresiduals::Vector{Vector{Float64}}: Per-protein residual vectors\nmean_residuals::Vector{Float64}: Mean residual per protein\npooled_residuals::Vector{Float64}: All residuals concatenated\npooled_fitted::Vector{Float64}: Fitted values parallel to pooled_residuals (for scale-location plots)\nskewness::Float64: Skewness of pooled residuals\nkurtosis::Float64: Excess kurtosis of pooled residuals\noutlier_proteins::Vector{String}: Proteins with |mean residual| > 2\n\n\n\n\n\n","category":"type"},{"location":"diagnostics/#BayesInteractomics.ProteinPPC","page":"Diagnostics","title":"BayesInteractomics.ProteinPPC","text":"ProteinPPC\n\nPosterior predictive check results for a single protein (HBM or regression model).\n\nFields\n\nprotein_name::String: Protein identifier\nmodel::Symbol: Which model produced this PPC (:hbm or :regression)\nobserved::Vector{Float64}: Observed data values\nsimulated::Matrix{Float64}: Simulated replicate data (nobs × ndraws)\npvalue_mean::Float64: Bayesian p-value for mean test statistic\npvalue_sd::Float64: Bayesian p-value for standard deviation test statistic\npvalue_log2fc::Float64: Bayesian p-value for log2FC test statistic (HBM only; NaN for regression)\n\n\n\n\n\n","category":"type"},{"location":"diagnostics/#BayesInteractomics.BetaBernoulliPPC","page":"Diagnostics","title":"BayesInteractomics.BetaBernoulliPPC","text":"BetaBernoulliPPC\n\nPosterior predictive check results for a single protein's Beta-Bernoulli detection model.\n\nFields\n\nprotein_name::String: Protein identifier\nobserved_k_sample::Int: Observed detection count in samples\nobserved_k_control::Int: Observed detection count in controls\nsimulated_k_sample::Vector{Int}: Simulated sample detection counts (length = n_draws)\nsimulated_k_control::Vector{Int}: Simulated control detection counts (length = n_draws)\npvalue_detection_diff::Float64: Bayesian p-value for detection difference (sample - control)\n\n\n\n\n\n","category":"type"},{"location":"diagnostics/#BayesInteractomics.ppc_density_plot","page":"Diagnostics","title":"BayesInteractomics.ppc_density_plot","text":"ppc_density_plot(ppc::ProteinPPC; file=\"\")\n\nOverlay observed data density with simulated posterior predictive densities.\n\nKeywords\n\nfile::String: If non-empty, save plot to this path\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/#BayesInteractomics.ppc_pvalue_histogram","page":"Diagnostics","title":"BayesInteractomics.ppc_pvalue_histogram","text":"ppc_pvalue_histogram(dr::DiagnosticsResult; model=:all, file=\"\")\n\nPlot histogram of Bayesian PPC p-values. Well-calibrated models produce a uniform distribution.\n\nKeywords\n\nmodel::Symbol: Filter by model (:all, :hbm, :regression, :betabernoulli)\nfile::String: If non-empty, save plot to this path\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/#BayesInteractomics.residual_qq_plot","page":"Diagnostics","title":"BayesInteractomics.residual_qq_plot","text":"residual_qq_plot(res::ResidualResult; file=\"\")\n\nQ-Q plot of standardized residuals against the standard Normal distribution.\n\nKeywords\n\nfile::String: If non-empty, save plot to this path\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/#BayesInteractomics.scale_location_plot","page":"Diagnostics","title":"BayesInteractomics.scale_location_plot","text":"scale_location_plot(res::ResidualResult; file=\"\", n_bins=30)\n\nScale-location plot: √|standardized residuals| vs fitted values.\n\nA flat smoother line indicates homoscedasticity; an increasing trend reveals variance that grows with the predicted value.\n\nKeywords\n\nfile::String: If non-empty, save plot to this path\nn_bins::Int: Number of equal-width bins for the binned smoother (default: 30)\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/#BayesInteractomics.residual_distribution_plot","page":"Diagnostics","title":"BayesInteractomics.residual_distribution_plot","text":"residual_distribution_plot(res::ResidualResult; file=\"\")\n\nHistogram of standardized residuals overlaid with a standard Normal density.\n\nKeywords\n\nfile::String: If non-empty, save plot to this path\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/#BayesInteractomics.calibration_plot","page":"Diagnostics","title":"BayesInteractomics.calibration_plot","text":"calibration_plot(cal::CalibrationResult; file=\"\")\n\nPredicted vs observed calibration plot with diagonal reference line.\n\nKeywords\n\nfile::String: If non-empty, save plot to this path\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/#BayesInteractomics.calibration_comparison_plot","page":"Diagnostics","title":"BayesInteractomics.calibration_comparison_plot","text":"calibration_comparison_plot(dr::DiagnosticsResult; file=\"\")\n\nOverlay calibration curves from all available proxies (strict, relaxed, enrichment-only) on a single plot for direct comparison.\n\nKeywords\n\nfile::String: If non-empty, save plot to this path\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/#BayesInteractomics.pit_histogram_plot","page":"Diagnostics","title":"BayesInteractomics.pit_histogram_plot","text":"pit_histogram_plot(pit_values::Vector{Float64}; n_bins=10, file=\"\")\n\nHistogram of PIT (Probability Integral Transform) values with Uniform(0,1) reference line.\n\nFor a well-specified model, PIT values should be uniformly distributed. Deviations indicate:\n\nU-shaped: underdispersion (model variance too small)\nInverse-U (hump): overdispersion (model variance too large)\nSkewed: location bias (systematic over/under-prediction)\n\nKeywords\n\nn_bins::Int: Number of histogram bins (default: 10)\ntitle::String: Plot title\nfile::String: If non-empty, save plot to this path\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/#BayesInteractomics.nu_optimization_plot","page":"Diagnostics","title":"BayesInteractomics.nu_optimization_plot","text":"nu_optimization_plot(res::NuOptimizationResult; file=\"\")\n\nPlot the WAIC vs ν curve from Student-t ν optimization, showing the optimal ν and the Normal model baseline.\n\nKeywords\n\nfile::String: If non-empty, save plot to this path\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/#BayesInteractomics.bb_ppc_summary_plot","page":"Diagnostics","title":"BayesInteractomics.bb_ppc_summary_plot","text":"bb_ppc_summary_plot(bb_ppcs::Vector{BetaBernoulliPPC}; n_top=20, file=\"\")\n\nBar chart showing observed detection differences alongside simulated median and range for the top proteins by detection difference.\n\nKeywords\n\nn_top::Int: Number of proteins to display\nfile::String: If non-empty, save plot to this path\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/#BayesInteractomics.sensitivity_tornado_plot","page":"Diagnostics","title":"BayesInteractomics.sensitivity_tornado_plot","text":"sensitivity_tornado_plot(sr::SensitivityResult; n_top=0, file=\"\")\n\nHorizontal bar chart showing the posterior probability range for the most sensitive proteins. Red diamonds mark the baseline posterior for each protein.\n\nKeywords\n\nn_top::Int: Number of top proteins to display (default: sr.config.n_top_proteins)\nfile::String: If non-empty, save the plot to this path\n\nReturns\n\nStatsPlots plot object\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/#BayesInteractomics.sensitivity_heatmap","page":"Diagnostics","title":"BayesInteractomics.sensitivity_heatmap","text":"sensitivity_heatmap(sr::SensitivityResult; n_top=0, file=\"\")\n\nHeatmap of posterior probabilities (proteins x prior settings) for the most sensitive proteins.\n\nKeywords\n\nn_top::Int: Number of top proteins to display (default: sr.config.n_top_proteins)\nfile::String: If non-empty, save the plot to this path\n\nReturns\n\nStatsPlots plot object\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/#BayesInteractomics.sensitivity_rank_correlation","page":"Diagnostics","title":"BayesInteractomics.sensitivity_rank_correlation","text":"sensitivity_rank_correlation(sr::SensitivityResult; file=\"\")\n\nHeatmap of mean absolute posterior difference between each pair of prior settings. Shows how much posterior probabilities diverge on average between any two settings. Values near 0 indicate agreement; larger values indicate prior sensitivity.\n\nKeywords\n\nfile::String: If non-empty, save the plot to this path\n\nReturns\n\nStatsPlots plot object\n\n\n\n\n\n","category":"function"},{"location":"analysis/#Analysis-Pipeline","page":"Analysis Pipeline","title":"Analysis Pipeline","text":"","category":"section"},{"location":"analysis/#Overview","page":"Analysis Pipeline","title":"Overview","text":"The analysis module orchestrates the complete workflow for identifying protein-protein interactions. It coordinates data loading, statistical modeling, evidence combination, and result generation into a seamless pipeline.\n\nBayesInteractomics provides two levels of entry points:\n\nrun_analysis(config): High-level function that handles everything from data loading to final results, with intelligent caching\nanalyse(data, ...): Lower-level function that runs the core Bayesian pipeline on pre-loaded data","category":"section"},{"location":"analysis/#Pipeline-Architecture","page":"Analysis Pipeline","title":"Pipeline Architecture","text":"","category":"section"},{"location":"analysis/#run_analysis-Workflow","page":"Analysis Pipeline","title":"run_analysis Workflow","text":"CONFIG\n  │\n  ├─ load_data() ──── Data loading & curation\n  │\n  ├─ Cache check ──── Skip if config+data unchanged\n  │\n  ├─ analyse() ────── Core Bayesian pipeline\n  │   ├── Step 1: Beta-Bernoulli (detection BFs)\n  │   ├── Step 2: HBM + Regression (enrichment & correlation BFs)\n  │   └── Step 3: Evidence combination (copula-EM or latent class)\n  │\n  ├─ Model comparison ── WAIC (Normal vs. robust regression)\n  │\n  ├─ Diagnostics ──── PPC, residuals, calibration (optional)\n  │\n  ├─ Sensitivity ──── Prior sensitivity analysis (optional)\n  │\n  ├─ Visualization ── Volcano, convergence, evidence plots\n  │\n  └─ Report ────────── Interactive HTML report (optional)","category":"section"},{"location":"analysis/#Core-Pipeline-(analyse)","page":"Analysis Pipeline","title":"Core Pipeline (analyse)","text":"The analyse() function implements a multi-stage Bayesian workflow:","category":"section"},{"location":"analysis/#Step-1:-H0-Computation","page":"Analysis Pipeline","title":"Step 1: H0 Computation","text":"Computes or loads null hypothesis Bayes factors from permuted data\nStores null distribution in copula_H0.xlsx\nRequired for copula-based evidence combination","category":"section"},{"location":"analysis/#Step-2:-Beta-Bernoulli-Detection-Model","page":"Analysis Pipeline","title":"Step 2: Beta-Bernoulli Detection Model","text":"Parallelized across all proteins:\n\nEstimates detection probabilities using a Beta-Bernoulli model\nGenerates Bayes factors for detection evidence\nThread-safe computation with progress bar","category":"section"},{"location":"analysis/#Step-3:-Hierarchical-Bayesian-Model-Regression","page":"Analysis Pipeline","title":"Step 3: Hierarchical Bayesian Model + Regression","text":"Parallelized analysis of enrichment and correlation:\n\nEnrichment (HBM): Log₂ fold-change across conditions using variational Bayes\nCorrelation (Regression): Dose-response relationships via Bayesian linear regression\nSupports both Normal and robust (Student-t) regression likelihoods\nResults cached in thread-specific files under cache/","category":"section"},{"location":"analysis/#Step-4:-Evidence-Combination","page":"Analysis Pipeline","title":"Step 4: Evidence Combination","text":"Two methods available:\n\nCopula-EM (:copula, default): Fits mixture of copulas with EM algorithm\nLatent Class (:latent_class): Variational message passing approach","category":"section"},{"location":"analysis/#Configuration","page":"Analysis Pipeline","title":"Configuration","text":"All analysis parameters are centralized in the CONFIG struct:\n\nconfig = CONFIG(\n    # Required: data and column specifications\n    datafile = [\"experiment.xlsx\"],\n    sample_cols = [Dict(1 => [5,6,7])],\n    control_cols = [Dict(1 => [2,3,4])],\n    poi = \"BAIT_PROTEIN\",\n\n    # Output paths (auto-generated from basedir)\n    output = OutputFiles(\"/path/to/results\"),\n    # or: output = OutputFiles(\"/path/to/results\", image_ext=\".svg\")\n\n    # Analysis parameters\n    n_controls = 3,\n    n_samples = 3,\n    refID = 1,\n    normalise_protocols = true,\n\n    # Evidence combination\n    combination_method = :copula,        # or :latent_class\n    em_prior = :default,                 # or :APMS, :BioID, :TurboID, :stringent, :permissive\n    em_n_restarts = 20,\n    copula_criterion = :BIC,\n\n    # Regression model\n    regression_likelihood = :robust_t,   # or :normal\n    student_t_nu = 5.0,\n    run_model_comparison = true,\n    optimize_nu = true,\n\n    # Diagnostics (optional)\n    run_diagnostics = false,\n    run_sensitivity = true,\n\n    # Data curation\n    curate = true,\n    species = 9606,\n    bait_name = \"BAIT_PROTEIN\",\n\n    # Report\n    generate_report_html = true\n)","category":"section"},{"location":"analysis/#Output-Files","page":"Analysis Pipeline","title":"Output Files","text":"All output paths are managed through the OutputFiles struct:\n\noutput = OutputFiles(\"/path/to/results\")\n# Auto-generates:\n#   copula_H0.xlsx, final_results.xlsx, volcano_plot.png,\n#   convergence.png, evidence.png, em_diagnostics.png,\n#   interactive_report.html, methods.md, ...\n\n# Override individual paths:\noutput.results_file = \"custom_name.xlsx\"\n\n# Use SVG instead of PNG:\noutput = OutputFiles(\"/path/to/results\", image_ext = \".svg\")","category":"section"},{"location":"analysis/#Caching","page":"Analysis Pipeline","title":"Caching","text":"","category":"section"},{"location":"analysis/#Result-Level-Caching","page":"Analysis Pipeline","title":"Result-Level Caching","text":"run_analysis uses hash-based caching to skip redundant computation:\n\n# First run: performs full analysis and caches\nfinal_df, result = run_analysis(config)\n\n# Second run with same config/data: loads from cache\nfinal_df, result = run_analysis(config)\n\n# Force re-computation\nfinal_df, result = run_analysis(config, use_cache = false)\n\nCache files are stored in .bayesinteractomics_cache/ next to the first data file.","category":"section"},{"location":"analysis/#Intermediate-Caching","page":"Analysis Pipeline","title":"Intermediate Caching","text":"Individual pipeline steps can be cached separately:\n\nresults = analyse(data, \"copula_H0.xlsx\",\n    use_intermediate_cache = true,\n    betabernoulli_cache_file = \"bb_cache.jld2\",\n    hbm_regression_cache_file = \"hbm_cache.jld2\"\n)\n\nThis is useful when iterating on copula-EM parameters without re-running inference.","category":"section"},{"location":"analysis/#Parallel-Processing","page":"Analysis Pipeline","title":"Parallel Processing","text":"The package uses Julia's multi-threading:\n\n# Launch Julia with multiple threads\njulia --threads=auto\n\nThread Safety: Each thread writes to separate cache files\nLoad Balancing: Proteins distributed evenly across threads\nError Handling: Failures logged per-protein to log.txt without blocking others","category":"section"},{"location":"analysis/#Multiple-Imputation","page":"Analysis Pipeline","title":"Multiple Imputation","text":"For handling missing data with multiple imputation:\n\n# Pass vector of imputed datasets + raw data\nresults = analyse(\n    imputed_data_vector,  # Vector{InteractionData}\n    raw_data,             # InteractionData (for Beta-Bernoulli)\n    \"copula_H0.xlsx\",\n    n_controls = 3, n_samples = 3, refID = 1\n)\n\nResults are automatically pooled:\n\nHBM and regression are run on each imputed dataset\nPooled using evaluate_imputed_fc_posteriors() (Rubin's rules)\nBeta-Bernoulli uses raw (non-imputed) data","category":"section"},{"location":"analysis/#Evidence-Combination-Methods","page":"Analysis Pipeline","title":"Evidence Combination Methods","text":"","category":"section"},{"location":"analysis/#Copula-EM-(default)","page":"Analysis Pipeline","title":"Copula-EM (default)","text":"combination_method = :copula\n\nFits mixture: π₀ · Copula(H₀) + π₁ · Copula(H₁)\nAutomatic copula selection (Clayton, Frank, Gumbel, Gaussian, Joe)\nMultiple restarts to avoid local optima\nSQUAREM acceleration for faster convergence\nSupports informative priors on π₁","category":"section"},{"location":"analysis/#Latent-Class","page":"Analysis Pipeline","title":"Latent Class","text":"combination_method = :latent_class\n\nVariational message passing approach\nDoes not require pre-computed H0 file\nWinsorization of extreme Bayes factors\nDirichlet prior on class proportions","category":"section"},{"location":"analysis/#Output-Structure","page":"Analysis Pipeline","title":"Output Structure","text":"run_analysis returns (final_df, analysis_result):","category":"section"},{"location":"analysis/#final_df-(DataFrame)","page":"Analysis Pipeline","title":"final_df (DataFrame)","text":"Column Description\nProtein Protein identifier\nBF Combined Bayes factor\nposterior_prob Posterior probability of interaction\nq Bayesian FDR q-value\nmean_log2FC Mean log₂ fold change\nbf_enrichment HBM Bayes factor\nbf_correlation Regression Bayes factor\nbf_detected Beta-Bernoulli Bayes factor\ndiagnostic_flag Quality flags (when diagnostics enabled)\nsensitivity_range Prior sensitivity range (when enabled)","category":"section"},{"location":"analysis/#analysis_result-(AnalysisResult)","page":"Analysis Pipeline","title":"analysis_result (AnalysisResult)","text":"Contains all analysis outputs including copula results, EM model, joint distributions, and caching metadata. Use accessor functions:\n\ngetProteins(result)              # Protein names\ngetBayesFactors(result)          # Combined BFs\ngetPosteriorProbabilities(result) # Posterior probabilities\ngetQValues(result)               # q-values\ngetMeanLog2FC(result)            # Mean log₂FC","category":"section"},{"location":"analysis/#API-Reference","page":"Analysis Pipeline","title":"API Reference","text":"","category":"section"},{"location":"analysis/#BayesInteractomics.run_analysis","page":"Analysis Pipeline","title":"BayesInteractomics.run_analysis","text":"run_analysis(config::CONFIG; use_cache=true, cache_file=\"\", temp_result_file=\"temp_results.xlsx\")\n\nRuns the complete analysis pipeline from data loading to final result generation with intelligent caching.\n\nThis function serves as a high-level wrapper that orchestrates the entire analysis workflow. It includes hash-based caching to avoid redundant computation when config and data haven't changed. The meta-learner is always re-run even when using cached results.\n\nArguments\n\nconfig::CONFIG: Configuration struct containing all analysis parameters\n\nKeywords\n\nuse_cache::Bool=true: Enable cache checking and saving\ncache_file::String=\"\": Custom cache file path (empty = auto-generate based on config)\ntemp_result_file::String=\"temp_results.xlsx\": Temporary results file during analysis\n\nReturns\n\nTuple{DataFrame, AnalysisResult}: A tuple containing:\nfinal_results::DataFrame: Final DataFrame with posterior probabilities updated by meta-learner\nanalysis_result::AnalysisResult: Complete analysis results with caching metadata\n\nCache Behavior\n\nOn cache hit: Loads copula results, EM results, and distributions from cache\nMeta-learner always runs (uses config.poi which may change between runs)\nPlots are always regenerated\nCache location: .bayesinteractomics_cache/ directory next to first data file\n\nSide Effects\n\nCreates cache file if use_cache=true and analysis runs\nCreates final results Excel file at config.output.results_file\nGenerates and saves plots (volcano, convergence, rank-rank, evidence)\nCreates and deletes temporary \"cache\" directory for intermediate files\nCreates \"log.txt\" file for logging errors during analysis\n\nExamples\n\nconfig = CONFIG(\n    datafile=[\"data.xlsx\"],\n    control_cols=[Dict(1=>[1,2,3])],\n    sample_cols=[Dict(1=>[4,5,6])],\n    poi=\"MyBaitProtein\",\n    n_controls=3,\n    n_samples=3,\n    refID=1\n)\n\n# First run - performs full analysis and caches results\nfinal_df, result = run_analysis(config)\n\n# Second run with same config/data - uses cache (fast!)\nfinal_df, result = run_analysis(config)\n\n# Disable caching\nfinal_df, result = run_analysis(config, use_cache=false)\n\n# Custom cache location\nfinal_df, result = run_analysis(config, cache_file=\"my_cache.jld2\")\n\nSee also: AnalysisResult, check_cache, analyse\n\n\n\n\n\nrun_analysis(config::CONFIG, imputed_data::Vector{InteractionData}, raw_data::InteractionData;\n             use_cache=true, cache_file=\"\")\n\nRuns analysis pipeline with multiple imputation and intelligent caching.\n\nSimilar to single-dataset version but uses multiple imputed datasets for HBM/regression and raw data for Beta-Bernoulli model. Cache validation uses combined hash of all datasets.\n\nArguments\n\nconfig::CONFIG: Configuration struct\nimputed_data::Vector{InteractionData}: Vector of imputed datasets\nraw_data::InteractionData: Original non-imputed data\n\nKeywords\n\nuse_cache::Bool=true: Enable cache checking and saving\ncache_file::String=\"\": Custom cache file path (empty = auto-generate)\n\nReturns\n\nTuple{DataFrame, AnalysisResult}: Final results and cached analysis result\n\nSee also: run_analysis(::CONFIG), AnalysisResult\n\n\n\n\n\n","category":"function"},{"location":"analysis/#BayesInteractomics.analyse","page":"Analysis Pipeline","title":"BayesInteractomics.analyse","text":"analyse(data, H0_file=\"copula_H0.xlsx\"; kwargs...)\n\nPerforms the main Bayesian analysis pipeline on the provided proteomics data.\n\nThis function integrates results from three different models:\n\nA Beta-Bernoulli model for detection probabilities.\nA hierarchical Bayesian model for protein enrichment (log2 fold change).\nA Bayesian linear regression model for dose-response correlation.\n\nThe Bayes factors from these models are combined using a copula to calculate a final, joint Bayes factor and posterior probability for each protein. The analysis is parallelized across proteins.\n\nArguments\n\ndata: The input data, typically from load_data, containing protein quantification data.\nH0_file::String: Path to the H0 file containing precomputed Bayes factors for the null hypothesis. If the file does not exist, it will be computed.\n\nKeywords\n\nBasic Analysis Parameters\n\nn_controls::Int=0: Number of controls in the dataset.\nn_samples::Int=0: Number of samples in the dataset.\nrefID::Int=1: The reference ID for the main analysis function, typically referring to a reference condition.\nplotHBMdists::Bool=false: If true, generates and saves plots of the hierarchical Bayesian model distributions.\nplotlog2fc::Bool=false: If true, generates and saves plots of the log2 fold changes.\nplotregr::Bool=false: If true, generates and saves plots of the regression model.\nplotbayesrange::Bool=false: If true, generates and saves plots of the Bayes factor ranges.\nverbose::Bool=false: If true, prints detailed progress and debugging information.\n\nCaching Parameters\n\ntemp_result_file::String=\"temp_results.xlsx\": Path for temporary results file.\nuse_intermediate_cache::Bool=true: If true, enables caching of intermediate results (Beta-Bernoulli and HBM+Regression).\nbetabernoulli_cache_file::String=\"\": Path to cache file for Beta-Bernoulli results. Empty string disables caching for this step.\nhbm_regression_cache_file::String=\"\": Path to cache file for HBM and regression results. Empty string disables caching for this step.\n\nCopula-EM Parameters\n\nprior::Union{Symbol, NamedTuple}=:default: Prior specification for the EM algorithm. Use :default for automatic prior or provide a NamedTuple with (α=..., β=...) for custom Beta prior parameters.\nn_restarts::Int=20: Number of random restarts for the EM algorithm to avoid local optima.\ncopula_criterion::Symbol=:BIC: Model selection criterion for copula fitting. Options: :BIC, :AIC.\nh1_refitting::Bool=true: If true, refits the H1 (alternative hypothesis) distribution after EM convergence.\nburn_in::Int=10: Number of initial EM iterations to discard before convergence checking.\n\nDiagnostics Parameters\n\nrun_em_diagnostics::Bool=true: If true and n_restarts > 1, runs diagnostic analysis of EM restart stability and convergence.\n\nReturns\n\nNamedTuple: A named tuple containing the analysis results with the following fields:\ncopula_results::DataFrame: DataFrame with combined Bayes factors, posterior probabilities, q-values, and other key metrics for each protein.\ndf_hierarchical::DataFrame: DataFrame with detailed results from the hierarchical and regression models.\nconvergence_plt: A plot diagnosing the convergence of the EM algorithm.\nem: The fitted Expectation-Maximization model object.\njoint_H0: The estimated joint distribution under the null hypothesis (H0).\njoint_H1: The estimated joint distribution under the alternative hypothesis (H1).\nem_diagnostics: Detailed diagnostics from EM restart analysis (if run_em_diagnostics=true and n_restarts > 1).\nem_diagnostics_summary: Summary statistics of EM diagnostics (if run_em_diagnostics=true and n_restarts > 1).\n\n\n\n\n\nanalyse(imputed_data, raw_data, H0_file=\"copula_H0.xlsx\"; kwargs...)\n\nPerforms the main Bayesian analysis pipeline on the provided proteomics data with multiple imputation.\n\nThis function integrates results from three different models:\n\nA Beta-Bernoulli model for detection probabilities.\nA hierarchical Bayesian model for protein enrichment (log2 fold change).\nA Bayesian linear regression model for dose-response correlation.\n\nThe Bayes factors from these models are combined using a copula to calculate a final, joint Bayes factor and posterior probability for each protein. The analysis is parallelized across proteins.\n\nArguments\n\nimputed_data::Vector{InteractionData}: The multiple imputed data set loaded as a vector of InteractionData objects. Used for HBM and regression models.\nraw_data::InteractionData: The non-imputed data. This dataset is used for the computation of the BF-detection (Beta-Bernoulli model).\nH0_file::String: Path to the H0 file containing precomputed Bayes factors for the null hypothesis. If the file does not exist, it will be computed.\n\nKeywords\n\nBasic Analysis Parameters\n\nn_controls::Int=0: Number of controls in the dataset.\nn_samples::Int=0: Number of samples in the dataset.\nrefID::Int=1: The reference ID for the main analysis function, typically referring to a reference condition.\nplotHBMdists::Bool=false: If true, generates and saves plots of the hierarchical Bayesian model distributions.\nplotlog2fc::Bool=false: If true, generates and saves plots of the log2 fold changes.\nplotregr::Bool=false: If true, generates and saves plots of the regression model.\nplotbayesrange::Bool=false: If true, generates and saves plots of the Bayes factor ranges.\nverbose::Bool=false: If true, prints detailed progress and debugging information.\n\nCaching Parameters\n\nuse_intermediate_cache::Bool=true: If true, enables caching of intermediate results (Beta-Bernoulli and HBM+Regression).\nbetabernoulli_cache_file::String=\"\": Path to cache file for Beta-Bernoulli results. Empty string disables caching for this step.\nhbm_regression_cache_file::String=\"\": Path to cache file for HBM and regression results. Empty string disables caching for this step.\n\nCopula-EM Parameters\n\nprior::Union{Symbol, NamedTuple}=:default: Prior specification for the EM algorithm. Use :default for automatic prior or provide a NamedTuple with (α=..., β=...) for custom Beta prior parameters.\nn_restarts::Int=20: Number of random restarts for the EM algorithm to avoid local optima.\ncopula_criterion::Symbol=:BIC: Model selection criterion for copula fitting. Options: :BIC, :AIC.\nh1_refitting::Bool=true: If true, refits the H1 (alternative hypothesis) distribution after EM convergence.\nburn_in::Int=10: Number of initial EM iterations to discard before convergence checking.\n\nDiagnostics Parameters\n\nrun_em_diagnostics::Bool=true: If true and n_restarts > 1, runs diagnostic analysis of EM restart stability and convergence.\n\nReturns\n\nNamedTuple: A named tuple containing the analysis results with the following fields:\ncopula_results::DataFrame: DataFrame with combined Bayes factors, posterior probabilities, q-values, and other key metrics for each protein.\ndf_hierarchical::DataFrame: DataFrame with detailed results from the hierarchical and regression models.\nconvergence_plt: A plot diagnosing the convergence of the EM algorithm.\nem: The fitted Expectation-Maximization model object.\njoint_H0: The estimated joint distribution under the null hypothesis (H0).\njoint_H1: The estimated joint distribution under the alternative hypothesis (H1).\nem_diagnostics: Detailed diagnostics from EM restart analysis (if run_em_diagnostics=true and n_restarts > 1).\nem_diagnostics_summary: Summary statistics of EM diagnostics (if run_em_diagnostics=true and n_restarts > 1).\n\n\n\n\n\n","category":"function"},{"location":"analysis/#BayesInteractomics.CONFIG","page":"Analysis Pipeline","title":"BayesInteractomics.CONFIG","text":"CONFIG\n\nA struct to hold all configuration parameters for the analysis pipeline.\n\nThis struct uses Base.@kwdef to allow initialization by keyword arguments.\n\nRequired Fields\n\ndatafile::Vector{String}: Paths to the input data files (e.g., Excel files).\ncontrol_cols::Vector{Dict{Int,Vector{Int}}}: Control columns for each data file.\nsample_cols::Vector{Dict{Int,Vector{Int}}}: Sample columns for each data file.\npoi::String: Identifier for the protein of interest (bait protein), used for the meta-learner.\n\nOutput\n\noutput::OutputFiles = OutputFiles(\".\"): Output file paths. Construct with OutputFiles(basedir) for auto-generated paths.\n\nAnalysis Parameters\n\nnormalise_protocols::Bool = true: Normalize data across different experimental protocols.\nn_controls::Int = 0: Number of control experiments.\nn_samples::Int = 0: Number of sample experiments.\nrefID::Int = 1: The ID of the reference (bait) protein or reference condition.\nplotHBMdists::Bool = false: Plot HBM posterior distributions per protein.\nplotlog2fc::Bool = false: Plot log2 fold-change distributions.\nplotregr::Bool = false: Plot regression model fits.\nplotbayesrange::Bool = false: Plot Bayes factor range plots.\nverbose::Bool = false: Enable verbose logging output.\nvc_legend_pos::Symbol = :topleft: Legend position in the volcano plot.\nmetalearner_path::String: Path to the metalearner model file.\n\nCopula-EM Parameters\n\nem_prior::Union{Symbol, NamedTuple{(:α, :β), ...}} = :default: Prior for EM algorithm (:default or named tuple).\nem_n_restarts::Int = 20: Number of random restarts for EM.\ncopula_criterion::Symbol = :BIC: Copula model selection criterion (:BIC or :AIC).\nh1_refitting::Bool = true: Re-fit H1 copula after initial EM.\nem_burn_in::Int = 10: EM burn-in iterations.\nrun_em_diagnostics::Bool = true: Generate EM convergence diagnostics.\n\nEvidence Combination\n\ncombination_method::Symbol = :bma: Evidence combination method (:copula, :latent_class, or :bma for Bayesian Model Averaging).\n\nLatent Class Parameters (used when combination_method = :latent_class)\n\nlc_n_iterations::Int = 100: Maximum EM iterations for latent class model.\nlc_alpha_prior::Vector{Float64} = [10.0, 1.0]: Dirichlet prior on class proportions.\nlc_convergence_tol::Float64 = 1e-6: Convergence tolerance.\nlc_winsorize::Bool = true: Winsorize extreme Bayes factors.\nlc_winsorize_quantiles::Tuple{Float64,Float64} = (0.01, 0.99): Winsorization quantiles.\n\nPrior Sensitivity Analysis\n\nrun_sensitivity::Bool = true: Run prior sensitivity analysis. Evaluates how robust posterior probabilities are to different prior specifications. Per-protein sensitivity metrics (std, min, max, range of posteriors; classification stability fractions) are merged into final_results.xlsx when diagnostics are also enabled.\nsensitivity_config::SensitivityConfig = SensitivityConfig(): Configuration for sensitivity analysis (prior grids for Beta-Bernoulli, EM, and latent class models).\n\nPosterior Predictive Checks & Model Diagnostics\n\nrun_diagnostics::Bool = false: Run posterior predictive checks and model diagnostics. When enabled, computes per-protein diagnostic flags (observation counts, residual outliers, low-data warnings) for ALL proteins and merges them as columns into final_results.xlsx. Extended PPC statistics (p-values for skewness, kurtosis, IQR ratio) are available for the subset of proteins selected for PPC. Set diagnostics_config.n_proteins_to_check to control how many proteins undergo full PPC (default 50; set to total protein count for exhaustive checks).\ndiagnostics_config::DiagnosticsConfig = DiagnosticsConfig(): Configuration for diagnostics (number of PPC draws, protein selection strategy, residual model, calibration bins, etc.).\n\nRegression Model Comparison\n\nrun_model_comparison::Bool = true: Run both Normal and robust regression models for all proteins and compare via WAIC. Refits regression posteriors for all proteins to compute pointwise WAIC.\nregression_likelihood::Symbol = :robust_t: Likelihood for regression models (:normal or :robust_t).\nstudent_t_nu::Float64 = 5.0: Degrees of freedom for Student-t distribution.\noptimize_nu::Bool = run_diagnostics: Optimize ν over [3, 50] via Brent's method minimizing WAIC. When true, automatically sets student_t_nu to the optimal value. Implies run_model_comparison (Normal WAIC is computed as baseline). Defaults to true when run_diagnostics is enabled.\n\n\n\n\n\n","category":"type"},{"location":"analysis/#BayesInteractomics.OutputFiles","page":"Analysis Pipeline","title":"BayesInteractomics.OutputFiles","text":"OutputFiles\n\nStruct holding all output file paths for the analysis pipeline.\n\nConstruct with OutputFiles(basedir) to auto-generate all paths under a single directory, or OutputFiles(basedir; image_ext=\".svg\") to change image format.\n\nIndividual paths can be overridden after construction since the struct is mutable.\n\nFields\n\nbasedir::String: Base directory for all output files.\nH0_file::String: Path to the null hypothesis Bayes factors file.\nresults_file::String: Path for the final results Excel file.\nvolcano_file::String: Path for the volcano plot image.\nconvergence_file::String: Path for the EM convergence diagnostic plot.\nevidence_file::String: Path for the evidence plot.\ndnn_file::String: Path for the DNN/metalearner results Excel file.\nrank_rank_file::String: Path for the rank-rank plot image.\nprior_file::String: Path for the prior Excel file.\nem_diagnostics_file::String: Path for the EM diagnostics plot.\nlc_convergence_file::String: Path for the latent class convergence plot.\nsensitivity_report_file::String: Path for the sensitivity analysis report.\nsensitivity_tornado_file::String: Path for the sensitivity tornado plot.\nsensitivity_heatmap_file::String: Path for the sensitivity heatmap plot.\nsensitivity_rankcorr_file::String: Path for the sensitivity rank correlation plot.\npit_histogram_file::String: Path for the PIT histogram plot.\nnu_optimization_file::String: Path for the Student-t ν optimization plot.\n\n\n\n\n\n","category":"type"},{"location":"analysis/#BayesInteractomics.AnalysisResult","page":"Analysis Pipeline","title":"BayesInteractomics.AnalysisResult","text":"AnalysisResult <: AbstractAnalysisResult\n\nComplete results container from a BayesInteractomics analysis run with caching support.\n\nThis structure stores all outputs from run_analysis() along with hash-based validation to enable intelligent caching and avoid redundant computation.\n\nFields\n\ncopula_results::DataFrame: Final results with combined Bayes factors, posterior probabilities, and q-values\ndf_hierarchical::DataFrame: Detailed hierarchical model results including individual protein statistics\nem::Union{EMResult, Nothing}: EM algorithm results from copula mixture fitting (copula mode only)\njoint_H0::Union{SklarDist, Nothing}: Fitted copula distribution under null hypothesis (copula mode only)\njoint_H1::Union{SklarDist, Nothing}: Fitted copula distribution under alternative hypothesis (copula mode only)\nlatent_class_result::Union{LatentClassResult, Nothing}: VMP latent class results (latent class mode only)\nbma_result::Union{BMAResult, Nothing}: BMA results (BMA mode only)\ncombination_method::Symbol: Evidence combination method used (:copula, :latent_class, or :bma)\nem_diagnostics::Union{DataFrame, Nothing}: EM algorithm restart diagnostics\nem_diagnostics_summary::Union{NamedTuple, Nothing}: Summary of EM restart diagnostics\nconfig_hash::UInt64: Hash of configuration parameters affecting computation (for cache validation)\ndata_hash::UInt64: Hash of input data (for cache validation)\ntimestamp::DateTime: Analysis completion time\npackage_version::String: Package version used for analysis\nbait_protein::Union{String, Nothing}: Name or ID of the bait protein\nbait_index::Union{Int, Nothing}: Index of bait protein in the protein list\nsensitivity::Union{SensitivityResult, Nothing}: Prior sensitivity analysis results (if run_sensitivity=true)\ndiagnostics::Union{DiagnosticsResult, Nothing}: Posterior predictive check and model diagnostics results (if run_diagnostics=true)\n\nIterator Interface\n\nIterates over (protein_name, row_data) tuples from copula_results.\n\nfor (protein, row) in result\n    println(\"$protein: BF = $(row.BF), q-value = $(row.q)\")\nend\n\nIndexing\n\nresult[i]: Get row i from copula_results (Integer indexing)\nresult[protein]: Get row for specific protein (String indexing)\n\nExamples\n\n# After analysis\nfinal_results, analysis_result = run_analysis(config)\n\n# Access results\nprintln(\"Analysis completed at: \", analysis_result.timestamp)\nprintln(\"Number of proteins: \", length(analysis_result))\n\n# Get specific protein\nrow = analysis_result[\"ProteinA\"]\nprintln(\"BF: \", row.BF, \", Q-value: \", row.q)\n\n# Iterate over all proteins\nfor (protein, data) in analysis_result\n    if data.posterior_prob > 0.95\n        println(\"$protein is likely an interactor\")\n    end\nend\n\n# Access sensitivity analysis (if available)\nif !isnothing(analysis_result.sensitivity)\n    sr = analysis_result.sensitivity\n    println(\"Tested \", length(sr.prior_settings), \" prior settings\")\n    println(\"Max posterior range: \", maximum(sr.summary.range))\nend\n\n# Save for later\nsave_result(analysis_result, \"analysis_cache.jld2\")\n\nSee also: save_result, load_result, check_cache, sensitivity_analysis\n\n\n\n\n\n","category":"type"},{"location":"analysis/#BayesInteractomics.save_result","page":"Analysis Pipeline","title":"BayesInteractomics.save_result","text":"save_result(result::AnalysisResult, filepath::String)\n\nSave AnalysisResult to disk using JLD2 format with compression.\n\nArguments\n\nresult::AnalysisResult: Result structure to save\nfilepath::String: Output file path (typically .jld2 extension)\n\nExamples\n\nsave_result(analysis_result, \".bayesinteractomics_cache/analysis_cache.jld2\")\n\nSee also: load_result, AnalysisResult\n\n\n\n\n\n","category":"function"},{"location":"analysis/#BayesInteractomics.load_result","page":"Analysis Pipeline","title":"BayesInteractomics.load_result","text":"load_result(filepath::String)::Union{AnalysisResult, Nothing}\n\nLoad AnalysisResult from disk, or return nothing if invalid/missing.\n\nReturns nothing if:\n\nFile doesn't exist\nCache version mismatch (indicates incompatible format)\nLoading fails due to corruption or other errors\n\nArguments\n\nfilepath::String: Path to cached result file\n\nReturns\n\nAnalysisResult: Loaded result structure\nnothing: If file is missing, incompatible, or corrupted\n\nExamples\n\ncached = load_result(\"analysis_cache.jld2\")\nif !isnothing(cached)\n    println(\"Loaded cached results from \", cached.timestamp)\nelse\n    println(\"No valid cache found, running analysis...\")\nend\n\nSee also: save_result, check_cache\n\n\n\n\n\n","category":"function"},{"location":"analysis/#BayesInteractomics.check_cache","page":"Analysis Pipeline","title":"BayesInteractomics.check_cache","text":"check_cache(cache_file::String, config::CONFIG, data)\n\nValidate cached results against current configuration and data.\n\nChecks if cached analysis results are still valid for the current config and data. Returns the cache status and loaded result (if valid).\n\nArguments\n\ncache_file::String: Path to cache file\nconfig::CONFIG: Current configuration\ndata: Current data (InteractionData or Tuple{Vector{InteractionData}, InteractionData})\n\nReturns\n\nTuple{CacheStatus, Union{AnalysisResult, Nothing}}: Status and cached result (if hit)\n\nCache Hit\n\nWhen status is CACHE_HIT, the second element contains the valid cached result.\n\nCache Miss\n\nWhen status is any MISS variant, the second element is nothing.\n\nExamples\n\nstatus, cached = check_cache(\"cache.jld2\", config, data)\n\nif status == CACHE_HIT\n    @info \"Using cached results from $(cached.timestamp)\"\n    # Use cached.copula_results, cached.joint_H0, etc.\nelseif status == CACHE_MISS_CONFIG\n    @info \"Config changed, recomputing...\"\nelseif status == CACHE_MISS_DATA\n    @info \"Data changed, recomputing...\"\nelse  # CACHE_MISS_NO_FILE\n    @info \"No cache found, running analysis...\"\nend\n\nSee also: CacheStatus, compute_config_hash, compute_data_hash\n\n\n\n\n\n","category":"function"},{"location":"analysis/#BayesInteractomics.evaluate_imputed_fc_posteriors","page":"Analysis Pipeline","title":"BayesInteractomics.evaluate_imputed_fc_posteriors","text":"evaluate_imputed_fc_posteriors(results, protocol_positions; kwargs...)\n\nPool Bayes factors and summary statistics from multiple imputation runs.\n\nCombines the posterior inference results from several imputed datasets (stored as a Vector{BayesResult}) using Rubin's pooling rules.  For each parameter the function computes mixture distributions across imputations, derives pooled Bayes factors for both the HBM and regression models, and generates optional diagnostic plots.\n\nArguments\n\nresults::Vector{BayesResult}: One BayesResult per imputed dataset for the same protein.\nprotocol_positions: Protocol position indices from InteractionData.\n\nKeywords\n\nplotlog2fc::Bool=false: Generate log₂FC distribution plots.\nplotbayesrange::Bool=false: Generate Bayes factor range plots.\nthreshold::Float64=0.0: Log₂FC threshold for hypothesis testing.\ncsv_file::String=\"results.csv\": Path to write pooled CSV results.\nwritecsv::Bool=true: Whether to write results to CSV.\nα::Float64=0.95: Credibility level for intervals.\n\nReturns\n\nNamedTuple with fields:\nbfHBM: Pooled Bayes factors from the hierarchical model\nHBM_stats: Pooled log₂FC summary statistics\nbfRegression: Pooled Bayes factors from the regression model\nregression_stats: Pooled regression summary statistics\n\n\n\n\n\n","category":"function"},{"location":"model_evaluation/#Model-Evaluation-and-Interpretation","page":"Model Evaluation","title":"Model Evaluation and Interpretation","text":"","category":"section"},{"location":"model_evaluation/#Overview","page":"Model Evaluation","title":"Overview","text":"After running the analysis pipeline, model evaluation tools help assess result quality, validate predictions, and interpret findings. This module provides statistical metrics and ranking systems for identifying high-confidence protein-protein interactions.","category":"section"},{"location":"model_evaluation/#Understanding-Bayesian-Evidence","page":"Model Evaluation","title":"Understanding Bayesian Evidence","text":"","category":"section"},{"location":"model_evaluation/#Bayes-Factor-Interpretation","page":"Model Evaluation","title":"Bayes Factor Interpretation","text":"The Bayes factor (BF) quantifies the ratio of evidence for interaction (H₁) versus no interaction (H₀):\n\nBayes Factor Evidence Strength Interpretation\n> 100 Decisive Very strong evidence for interaction\n10-100 Strong Strong evidence for interaction\n3-10 Moderate Moderate evidence for interaction\n1-3 Weak Weak evidence for interaction\n0.33-1 Weak Weak evidence against interaction\n0.1-0.33 Moderate Moderate evidence against interaction\n< 0.1 Strong Strong evidence against interaction","category":"section"},{"location":"model_evaluation/#Converting-to-Posterior-Probability","page":"Model Evaluation","title":"Converting to Posterior Probability","text":"The posterior probability of an interaction given the data is computed from the Bayes factor:\n\nP(H_1data) = fracBF cdot P(H_1)BF cdot P(H_1) + P(H_0)\n\nWith uniform priors (P(H₀) = P(H₁) = 0.5):\n\nBayes Factor Posterior Probability Confidence\n99 0.99 99%\n9 0.90 90%\n3 0.75 75%\n1 0.50 50% (inconclusive)","category":"section"},{"location":"model_evaluation/#Model-Performance-Evaluation","page":"Model Evaluation","title":"Model Performance Evaluation","text":"","category":"section"},{"location":"model_evaluation/#Calibration-Assessment","page":"Model Evaluation","title":"Calibration Assessment","text":"Check if posterior probabilities match actual discovery rates:\n\nGenerate predictions across range of probability thresholds\nValidate with independent data or orthogonal methods\nCompare observed vs expected interaction rates\nAdjust threshold if systematic bias detected","category":"section"},{"location":"model_evaluation/#Confidence-by-Evidence-Source","page":"Model Evaluation","title":"Confidence by Evidence Source","text":"Evaluate which models contribute most to predictions:\n\nDetection-dominated: Reliable detection but weak enrichment evidence\nEnrichment-dominated: Strong fold-change but variable detection\nCorrelation-dominated: Dose-response but limited to titration experiments\nWell-balanced: All three evidence sources agree strongly\n\nWell-balanced results are most trustworthy and reproducible.","category":"section"},{"location":"model_evaluation/#Result-Ranking-and-Filtering","page":"Model Evaluation","title":"Result Ranking and Filtering","text":"","category":"section"},{"location":"model_evaluation/#High-Confidence-Interactions","page":"Model Evaluation","title":"High-Confidence Interactions","text":"Recommended filtering criteria:\n\n# Strong candidates for validation\nstrong_interactions = filter(row -> row.posterior_prob > 0.95, results)\n\n# Moderate confidence (exploratory)\nmoderate = filter(row -> 0.75 < row.posterior_prob <= 0.95, results)\n\n# Known interactions (positive controls)\nknown = filter(row -> row.posterior_prob > 0.5, results)","category":"section"},{"location":"model_evaluation/#Per-Protein-Statistics","page":"Model Evaluation","title":"Per-Protein Statistics","text":"Analyze interaction profiles:\n\nNumber of interactions per protein (hub vs peripheral)\nPosterior probability distribution across interactors\nEvidence quality (Bayes factors by model)\nReproducibility (consistency across protocols)","category":"section"},{"location":"model_evaluation/#Protocol-Comparison","page":"Model Evaluation","title":"Protocol Comparison","text":"When multiple experimental protocols are available:\n\nIndividual protocol results: Bayes factors per method\nCross-protocol agreement: Proteins detected in multiple methods\nDiscrepancies: Investigate proteins with conflicting evidence\nMeta-analysis: Combine evidence across protocols","category":"section"},{"location":"model_evaluation/#Interpretation-Guidelines","page":"Model Evaluation","title":"Interpretation Guidelines","text":"","category":"section"},{"location":"model_evaluation/#What-High-Posterior-Probability-Means","page":"Model Evaluation","title":"What High Posterior Probability Means","text":"A posterior probability of 0.95 indicates:\n\nGiven your data and statistical assumptions\nThere is 95% probability this protein truly interacts\n5% probability it's a false positive (background)\nAssumes prior knowledge incorporated in priors","category":"section"},{"location":"model_evaluation/#What-Could-Go-Wrong","page":"Model Evaluation","title":"What Could Go Wrong","text":"False Positives (predicted interaction, actually background):\n\nSystematic contamination in control samples\nInappropriate copula model for your data\nPrior misspecification\n\nFalse Negatives (no interaction predicted, actually present):\n\nProteins with variable detection across replicates\nLow abundance interactors below detection limit\nTransient or weak interactions\n\nInconclusive Results (BF near 1):\n\nInsufficient power (too few replicates)\nConflicting evidence across models\nData quality issues","category":"section"},{"location":"model_evaluation/#Validation-Strategies","page":"Model Evaluation","title":"Validation Strategies","text":"Orthogonal Methods\nCo-immunoprecipitation (co-IP)\nYeast two-hybrid (Y2H)\nProximity labeling variants\nLiterature Comparison\nCross-reference with known interaction databases\nCheck PubMed for direct evidence\nBiological Validation\nFunctional assays\nLocalization studies\nPathway analysis","category":"section"},{"location":"model_evaluation/#Multiple-Testing-Correction","page":"Model Evaluation","title":"Multiple Testing Correction","text":"When reporting interactions across many proteins:","category":"section"},{"location":"model_evaluation/#False-Discovery-Rate-(FDR)","page":"Model Evaluation","title":"False Discovery Rate (FDR)","text":"BayesInteractomics naturally handles multiple testing through the Bayesian framework:\n\nNo correction needed (Bayesian approach)\nPosterior probabilities already account for uncertainty\nHowever, when making binary decisions, apply FDR control:\n\nusing StatsBase\n\n# Rank by posterior probability\nsorted = sort(results, :posterior_prob, rev=true)\n\n# Compute FDR\ndiscovered = cumsum(.!sorted.interaction)  # Count false discoveries\nfdr = discovered ./ (1:nrow(sorted))        # Running FDR\n\n# Select threshold where FDR < 0.05\nthreshold_idx = findfirst(fdr .< 0.05)","category":"section"},{"location":"model_evaluation/#Pooled-Results-from-Imputation","page":"Model Evaluation","title":"Pooled Results from Imputation","text":"When using multiple imputation:","category":"section"},{"location":"model_evaluation/#Interpreting-Pooled-Statistics","page":"Model Evaluation","title":"Interpreting Pooled Statistics","text":"Point estimates: Averaged across imputations\nUncertainty inflation: Total variance includes:\nWithin-imputation variance\nBetween-imputation variance (missing data)\nAlways use pooled posterior probabilities (not individual imputations)","category":"section"},{"location":"model_evaluation/#Checking-Imputation-Quality","page":"Model Evaluation","title":"Checking Imputation Quality","text":"Convergence: Estimates stable across imputations\nBetween-imputation variance: Should be < 25% of total variance\nSensitivity: Results robust to imputation method choice","category":"section"},{"location":"model_evaluation/#Reporting-Results","page":"Model Evaluation","title":"Reporting Results","text":"","category":"section"},{"location":"model_evaluation/#Recommended-Statistics-to-Report","page":"Model Evaluation","title":"Recommended Statistics to Report","text":"For each high-confidence interaction:\n\nPosterior probability\nCombined Bayes factor\nIndividual Bayes factors (detection, enrichment, correlation)\nLog₂ fold-change (with credible interval)\nNumber of independent protocols/experiments supporting","category":"section"},{"location":"model_evaluation/#Supplementary-Materials","page":"Model Evaluation","title":"Supplementary Materials","text":"Provide for reproducibility:\n\nPosterior probability distribution plots\nCalibration curves (predicted vs observed interaction rates)\nPer-protocol results and agreement statistics\nProtocol specifications and column mappings","category":"section"},{"location":"model_evaluation/#API-Reference","page":"Model Evaluation","title":"API Reference","text":"","category":"section"},{"location":"model_evaluation/#BayesInteractomics.Ranks-Tuple{Vector, Vector{String}}","page":"Model Evaluation","title":"BayesInteractomics.Ranks","text":"Ranks(posteriors::Vector, entity_names::Vector{String}; n::Int = 1000) -> Ranks\n\nConstruct a Ranks object from a collection of posterior distributions.\n\nThis function draws n samples from each posterior distribution, ranks the values across distributions for each sample (column-wise), and returns a Ranks object that contains the full rank matrix along with summary statistics (mean and median ranks).\n\nArguments\n\nposteriors::Vector: A vector of univariate distribution objects that support rand.\nentity_names::Vector{String}: A vector of names (e.g., parameter or protein names), one for each posterior.\nn::Int=1000: The number of random samples to draw from each posterior (default: 1000).\n\nReturns\n\nA Ranks struct with the following fields:\nranks::Matrix{Int}: Matrix of rank values (rows = parameters, columns = samples).\nentity_names::Vector{String}: Names of each parameter/posterior.\nmean_ranks::Vector{Float64}: Mean rank across samples.\nmedian_ranks::Vector{Float64}: Median rank across samples.\n\nNotes\n\nHigher values are ranked as better (rank 1 = highest value).\nRanking is performed independently for each sample column.\nRanks can be used to summarize the relative position of posterior distributions.\n\n\n\n\n\n","category":"method"},{"location":"model_evaluation/#BayesInteractomics.plot","page":"Model Evaluation","title":"BayesInteractomics.plot","text":"plot(data::Ranks)\n\nFunction to plot the ranks\n\nTBW\n\n\n\n\n\n","category":"function"},{"location":"model_evaluation/#BayesInteractomics.top","page":"Model Evaluation","title":"BayesInteractomics.top","text":"top(r::Ranks, n::Integer = 5)\n\nReturn the top n entities with the lowest mean rank.\n\n\n\n\n\n","category":"function"},{"location":"data_loading/#Data-Loading","page":"Data Loading","title":"Data Loading","text":"This page explains how to load and structure your mass spectrometry data for analysis with BayesInteractomics.","category":"section"},{"location":"data_loading/#Overview","page":"Data Loading","title":"Overview","text":"BayesInteractomics uses a hierarchical data structure that naturally reflects experimental design:\n\nInteractionData\n├── Protocol 1 (e.g., GST-tagged AP-MS)\n│   ├── Experiment 1 (biological replicate set 1)\n│   │   ├── Control samples: [c1, c2, c3]\n│   │   └── Bait samples: [s1, s2, s3]\n│   ├── Experiment 2 (biological replicate set 2)\n│   │   ├── Control samples: [c4, c5]\n│   │   └── Bait samples: [s4, s5]\n│   └── ...\n└── Protocol 2 (e.g., Strep-tagged AP-MS)\n    ├── Experiment 1\n    │   ├── Control samples: [c1, c2, c3, c4]\n    │   └── Bait samples: [s1, s2, s3]\n    └── ...\n\nThis structure enables:\n\nProtocol-level modeling: Account for systematic differences between experimental methods\nExperiment-level variation: Handle batch effects within protocols\nSample-level observations: Work with individual replicate measurements\nMissing data handling: Naturally accommodate proteins not detected in all replicates","category":"section"},{"location":"data_loading/#Data-Format-Requirements","page":"Data Loading","title":"Data Format Requirements","text":"","category":"section"},{"location":"data_loading/#File-Formats","page":"Data Loading","title":"File Formats","text":"BayesInteractomics supports:\n\nExcel files (.xlsx) - Recommended for most users\nCSV files (.csv) - Alternative for programmatic workflows","category":"section"},{"location":"data_loading/#Data-Matrix-Structure","page":"Data Loading","title":"Data Matrix Structure","text":"Your data files should be organized as:\n\nColumn 1 Column 2 Column 3 ... Column N\nProtein ID Sample/Control 1 Sample/Control 2 ... Sample/Control N\nPROTEIN_A 25.3 24.8 ... 28.5\nPROTEIN_B 22.1 NA ... 22.0\nBAIT 18.2 18.5 ... 32.1\n\nRequirements:\n\nFirst column: Protein identifiers (e.g., UniProt IDs, gene names, Ensembl IDs)\nSubsequent columns: Intensity values for each sample\nValues: Preferably log2-transformed intensities (though not strictly required)\nMissing data: Leave cells empty, use NA, or use Julia missing\nConsistent protein order: All files should have proteins in the same order","category":"section"},{"location":"data_loading/#Intensity-Normalization","page":"Data Loading","title":"Intensity Normalization","text":"It's recommended to:\n\nLog-transform intensities (log2 or ln) before loading\nWithin-sample normalization (e.g., median normalization, TMM) if appropriate\nLet BayesInteractomics handle protocol normalization via normalise_protocols=true","category":"section"},{"location":"data_loading/#Loading-Data:-Column-Specification","page":"Data Loading","title":"Loading Data: Column Specification","text":"The key to loading data correctly is specifying which columns contain which samples.","category":"section"},{"location":"data_loading/#Column-Mapping-Format","page":"Data Loading","title":"Column Mapping Format","text":"Column mappings use nested dictionaries:\n\nsample_cols = [\n    # Protocol 1 column mapping\n    Dict(\n        1 => [5, 6, 7],      # Experiment 1: columns 5-7\n        2 => [8, 9]          # Experiment 2: columns 8-9\n    ),\n\n    # Protocol 2 column mapping\n    Dict(\n        1 => [11, 12, 13, 14]  # Experiment 1: columns 11-14\n    )\n]\n\nStructure:\n\nOuter array: One element per protocol\nInner Dict: Maps experiment IDs to column indices\nColumn indices: 1-based (Julia convention), column 1 is protein IDs","category":"section"},{"location":"data_loading/#Example:-Single-Protocol","page":"Data Loading","title":"Example: Single Protocol","text":"For a simple experiment with one protocol and two experiments:\n\nusing BayesInteractomics\n\n# Data file structure:\n# Column 1: Protein IDs\n# Columns 2-4: Control replicates from experiment 1\n# Columns 5-7: Control replicates from experiment 2\n# Columns 8-10: Sample replicates from experiment 1\n# Columns 11-13: Sample replicates from experiment 2\n\ncontrol_cols = [\n    Dict(\n        1 => [2, 3, 4],      # Experiment 1 controls\n        2 => [5, 6, 7]       # Experiment 2 controls\n    )\n]\n\nsample_cols = [\n    Dict(\n        1 => [8, 9, 10],     # Experiment 1 samples\n        2 => [11, 12, 13]    # Experiment 2 samples\n    )\n]\n\n# Load data\ndata = load_data(\n    [\"experiment_data.xlsx\"],\n    sample_cols,\n    control_cols,\n    normalise_protocols = false  # Single protocol, no normalization needed\n)","category":"section"},{"location":"data_loading/#Example:-Multiple-Protocols","page":"Data Loading","title":"Example: Multiple Protocols","text":"For combining data from different experimental methods:\n\n# Protocol 1: AP-MS with GST tag (file: apms_gst.xlsx)\n# Protocol 2: AP-MS with Strep tag (file: apms_strep.xlsx)\n\n# Protocol 1 has 2 experiments, Protocol 2 has 1 experiment\n\ncontrol_cols = [\n    # Protocol 1\n    Dict(1 => [2, 3, 4], 2 => [5, 6]),\n\n    # Protocol 2\n    Dict(1 => [2, 3, 4, 5])\n]\n\nsample_cols = [\n    # Protocol 1\n    Dict(1 => [7, 8, 9], 2 => [10, 11, 12]),\n\n    # Protocol 2\n    Dict(1 => [6, 7, 8])\n]\n\ndata = load_data(\n    [\"apms_gst.xlsx\", \"apms_strep.xlsx\"],\n    sample_cols,\n    control_cols,\n    normalise_protocols = true  # IMPORTANT: Normalize across protocols\n)","category":"section"},{"location":"data_loading/#The-load_data-Function","page":"Data Loading","title":"The load_data Function","text":"","category":"section"},{"location":"data_loading/#Basic-Usage","page":"Data Loading","title":"Basic Usage","text":"data = load_data(\n    files::Vector{String},\n    sample_cols::Vector{Dict{Int, Vector{Int}}},\n    control_cols::Vector{Dict{Int, Vector{Int}}};\n    normalise_protocols::Bool = false\n)","category":"section"},{"location":"data_loading/#Parameters","page":"Data Loading","title":"Parameters","text":"files: Vector of file paths (one per protocol)\nsample_cols: Column mappings for bait/treatment samples\ncontrol_cols: Column mappings for negative control samples\nnormalise_protocols: If true, normalizes data across protocols using z-score transformation","category":"section"},{"location":"data_loading/#Return-Value","page":"Data Loading","title":"Return Value","text":"Returns an InteractionData object containing:\n\nAll protocols with their experiments\nSample and control data for each experiment\nProtein identifiers\nMetadata about data structure (positions, dimensions)","category":"section"},{"location":"data_loading/#Data-Structure-Reference","page":"Data Loading","title":"Data Structure Reference","text":"","category":"section"},{"location":"data_loading/#InteractionData-Type","page":"Data Loading","title":"InteractionData Type","text":"The InteractionData type is the central data container:\n\n# Access protocols\nfor protocol in data\n    println(\"Protocol: $(protocol.name)\")\n\n    # Access experiments within protocol\n    for (exp_id, experiment_data) in protocol.experiments\n        println(\"  Experiment $exp_id\")\n        println(\"    Size: $(size(experiment_data))\")\n    end\nend\n\n# Get number of proteins\nn_proteins = getNoProteins(data)\n\n# Get number of protocols\nn_protocols = getNoProtocols(data)\n\n# Extract data for specific protein\nprotein_data = getProteinData(data, protein_index)","category":"section"},{"location":"data_loading/#Protocol-Type","page":"Data Loading","title":"Protocol Type","text":"Each protocol contains:\n\nname: Protocol identifier\nproteinNames: Vector of protein IDs\nexperiments: Dictionary mapping experiment IDs to data matrices","category":"section"},{"location":"data_loading/#Protein-Type","page":"Data Loading","title":"Protein Type","text":"Extracting protein-specific data:\n\nprotein = getProteinData(data, 42)  # Get protein at index 42\n\n# Access samples and controls for each protocol\nfor (protocol_idx, (samples, controls)) in enumerate(protein)\n    println(\"Protocol $protocol_idx:\")\n    println(\"  Samples: $samples\")\n    println(\"  Controls: $controls\")\nend","category":"section"},{"location":"data_loading/#Worked-Example","page":"Data Loading","title":"Worked Example","text":"Let's walk through loading a complete dataset:","category":"section"},{"location":"data_loading/#Step-1:-Prepare-Your-Files","page":"Data Loading","title":"Step 1: Prepare Your Files","text":"Suppose you have:\n\nprotocol1.xlsx: AP-MS data with 2 experiments\nprotocol2.xlsx: BioID data with 1 experiment\n\nEach file has the same proteins in the same order.","category":"section"},{"location":"data_loading/#Step-2:-Identify-Column-Indices","page":"Data Loading","title":"Step 2: Identify Column Indices","text":"Open your files and note which columns contain which data:\n\nprotocol1.xlsx:\n\nColumn 1: Protein IDs\nColumns 2-4: Experiment 1 controls (3 replicates)\nColumns 5-7: Experiment 1 samples (3 replicates)\nColumns 8-10: Experiment 2 controls (3 replicates)\nColumns 11-13: Experiment 2 samples (3 replicates)\n\nprotocol2.xlsx:\n\nColumn 1: Protein IDs\nColumns 2-5: Experiment 1 controls (4 replicates)\nColumns 6-8: Experiment 1 samples (3 replicates)","category":"section"},{"location":"data_loading/#Step-3:-Create-Column-Mappings","page":"Data Loading","title":"Step 3: Create Column Mappings","text":"control_cols = [\n    # Protocol 1 (2 experiments)\n    Dict(1 => [2, 3, 4], 2 => [8, 9, 10]),\n\n    # Protocol 2 (1 experiment)\n    Dict(1 => [2, 3, 4, 5])\n]\n\nsample_cols = [\n    # Protocol 1 (2 experiments)\n    Dict(1 => [5, 6, 7], 2 => [11, 12, 13]),\n\n    # Protocol 2 (1 experiment)\n    Dict(1 => [6, 7, 8])\n]","category":"section"},{"location":"data_loading/#Step-4:-Load-the-Data","page":"Data Loading","title":"Step 4: Load the Data","text":"using BayesInteractomics\n\ndata = load_data(\n    [\"protocol1.xlsx\", \"protocol2.xlsx\"],\n    sample_cols,\n    control_cols,\n    normalise_protocols = true\n)\n\n@info \"Loaded data successfully\"\n@info \"Proteins: $(getNoProteins(data))\"\n@info \"Protocols: $(getNoProtocols(data))\"","category":"section"},{"location":"data_loading/#Step-5:-Verify-the-Data","page":"Data Loading","title":"Step 5: Verify the Data","text":"# Check structure\nprintln(\"Protocol 1:\")\nfor (exp_id, exp_data) in data.protocols[1].experiments\n    println(\"  Experiment $exp_id: $(size(exp_data))\")\nend\n\nprintln(\"Protocol 2:\")\nfor (exp_id, exp_data) in data.protocols[2].experiments\n    println(\"  Experiment $exp_id: $(size(exp_data))\")\nend\n\n# Check a specific protein\nprotein_42 = getProteinData(data, 42)\nprintln(\"\\nProtein at index 42:\")\nprintln(\"  Name: $(protein_42.name)\")\nprintln(\"  Protocol 1 samples: $(protein_42[1][1])\")\nprintln(\"  Protocol 1 controls: $(protein_42[1][2])\")","category":"section"},{"location":"data_loading/#Protocol-Normalization","page":"Data Loading","title":"Protocol Normalization","text":"When normalise_protocols = true, BayesInteractomics applies z-score normalization to each protocol:\n\nx_textnorm = fracx - musigma\n\nwhere mu and sigma are computed from all samples within that protocol.\n\nWhen to use:\n\n✅ Multiple protocols with potentially different intensity scales\n✅ Combining data from different labs or instruments\n✅ Different experimental methods (e.g., AP-MS vs BioID)\n\nWhen not to use:\n\n❌ Single protocol analysis\n❌ Data already normalized to common scale\n❌ Relative quantification methods (e.g., SILAC ratios)","category":"section"},{"location":"data_loading/#Troubleshooting","page":"Data Loading","title":"Troubleshooting","text":"","category":"section"},{"location":"data_loading/#Common-Errors-and-Solutions","page":"Data Loading","title":"Common Errors and Solutions","text":"Error: \"Column index out of bounds\"\n\nCause: Column indices don't match file structure\n\nSolution:\n\nCheck that column indices are 1-based\nVerify file has the expected number of columns\nRemember column 1 is protein IDs\n\n\n\nError: \"Protein names don't match across files\"\n\nCause: Different files have different protein sets or different order\n\nSolution:\n\nEnsure all files contain the same proteins\nProteins must be in the same row order across files\nUse the same protein ID format in all files\n\n\n\nError: \"All values missing for protein X\"\n\nCause: Protein has no detected values in any sample\n\nSolution:\n\nThis is a warning, not an error\nProteins with all missing values will have undefined Bayes factors\nConsider pre-filtering proteins detected in at least some samples\n\n\n\nError: \"refID protein not found\"\n\nCause: The bait protein specified by refID doesn't exist at that row index\n\nSolution:\n\nVerify the row number of your bait protein (1-indexed)\nCheck that bait protein is present in all data files\nUse findfirst(==(\"BAIT_ID\"), protein_ids) to find the correct index","category":"section"},{"location":"data_loading/#Best-Practices","page":"Data Loading","title":"Best Practices","text":"Consistent formatting: Use the same protein ID format across all files\nQuality control: Pre-filter proteins detected in very few samples\nMissing data: Don't artificially impute zeros - leave as missing\nLog transformation: Apply log2 transformation before loading if using raw intensities\nDocumentation: Keep notes on column mappings for future reference\nValidation: Always inspect loaded data structure before running analysis","category":"section"},{"location":"data_loading/#API-Reference","page":"Data Loading","title":"API Reference","text":"Functions for loading and processing AP-MS and proximity labeling data.","category":"section"},{"location":"data_loading/#BayesInteractomics.append_unique!-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T","page":"Data Loading","title":"BayesInteractomics.append_unique!","text":"append_unique!(v1::Vector{T}, v2::Vector{T}) where T\n\nAppends the elements of `v2` to `v1` if they are not already in `v1` and stores the result in `v1`.\n\n\n\n\n\n","category":"method"},{"location":"data_loading/#BayesInteractomics.cdf_log2FC-Tuple{Any}","page":"Data Loading","title":"BayesInteractomics.cdf_log2FC","text":"cdf_log2FC(log2FC}; threshold::Float64 = 0.0)\n\nCompute the cumulative density probability of the log2FC for x <= threshold. \n\nArgs:\n    - log2FC<:Normal{Float64}: log2FC distribution (computed via log2FC)\n    - threshold<:Float64: threshold\n\nReturns:\n    - cdf_log2FC<:Float64: cdf_log2FC\n\n\n\n\n\n","category":"method"},{"location":"data_loading/#BayesInteractomics.encode_png_file-Tuple{AbstractString}","page":"Data Loading","title":"BayesInteractomics.encode_png_file","text":"encode_png_file(filepath) -> String\n\nRead a PNG/image file and return a data:image/png;base64,... URI string suitable for embedding in HTML.  Returns \"\" if the file does not exist.\n\n\n\n\n\n","category":"method"},{"location":"data_loading/#BayesInteractomics.json_array-Tuple{AbstractVector{<:AbstractString}}","page":"Data Loading","title":"BayesInteractomics.json_array","text":"json_array(items) -> String\n\nSerialize a vector of already-serialized JSON strings to a JSON array.\n\n\n\n\n\n","category":"method"},{"location":"data_loading/#BayesInteractomics.json_bool-Tuple{Bool}","page":"Data Loading","title":"BayesInteractomics.json_bool","text":"json_bool(b) -> String\n\nSerialize a Bool to a JSON literal.\n\n\n\n\n\n","category":"method"},{"location":"data_loading/#BayesInteractomics.json_number-Tuple{Any}","page":"Data Loading","title":"BayesInteractomics.json_number","text":"json_number(x) -> String\n\nSerialize a numeric value to a JSON literal. Returns \"null\" for missing, NaN, and Inf.\n\n\n\n\n\n","category":"method"},{"location":"data_loading/#BayesInteractomics.json_object-Tuple{Vararg{Pair{<:AbstractString, <:AbstractString}}}","page":"Data Loading","title":"BayesInteractomics.json_object","text":"json_object(pairs...) -> String\n\nBuild a JSON object from alternating (key, already-serialized-value) pairs. Keys are auto-quoted; values must already be valid JSON strings.\n\n\n\n\n\n","category":"method"},{"location":"data_loading/#BayesInteractomics.json_string-Tuple{AbstractString}","page":"Data Loading","title":"BayesInteractomics.json_string","text":"json_string(s) -> String\n\nSerialize a string to a JSON string literal with proper escaping.\n\n\n\n\n\n","category":"method"},{"location":"data_loading/#BayesInteractomics.log2FC-Tuple{Distributions.Distribution{Distributions.Univariate, Distributions.Continuous}, Distributions.Distribution{Distributions.Univariate, Distributions.Continuous}}","page":"Data Loading","title":"BayesInteractomics.log2FC","text":"log2FC(sample::PosteriorNormalFamily, control::PosteriorNormalFamily)\n\nCompute the log2FC between the sample and control and return a Normal distribution.\n\nArgs:\n    - sample<:Union{NormalWeightedMeanPrecision{Float64},NormalMeanPrecision{Float64}}: sample (result of inference)\n    - control<:Union{NormalWeightedMeanPrecision{Float64},NormalMeanPrecision{Float64}}: control (result of inference)\n\nReturns:\n    - log2FC<:Normal{Float64}: log2FC\n\n\n\n\n\n","category":"method"},{"location":"data_loading/#BayesInteractomics.q-Tuple{Any}","page":"Data Loading","title":"BayesInteractomics.q","text":"q(values; isBF::Bool = true)\n\nComputes q-values from a vector of Bayes Factors or posterior probabilities, correctly and robustly handling missing values.\n\n\n\n\n\n","category":"method"},{"location":"data_loading/#BayesInteractomics.to_normal-Tuple{RxInfer.InferenceResult, Symbol}","page":"Data Loading","title":"BayesInteractomics.to_normal","text":"to_normal(x::InferenceResult, key::Symbol)\nConvert posterior to Normal distribution.\n\nArgs:\n    - x<:InferenceResult:     inference result object of type InferenceResult\n    - key<:Symbol:            key of the posterior distribution\n\nReturns:\n    - Vector{Normal{Float64}}\n\n\n\n\n\n","category":"method"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"Complete index of all documented functions and types.\n\n","category":"section"},{"location":"mathematical_background/#Mathematical-Background","page":"Mathematical Background","title":"Mathematical Background","text":"This document provides a detailed mathematical exposition of the statistical framework implemented in BayesInteractomics. The package integrates three complementary Bayesian models to identify genuine protein-protein interactions from mass spectrometry data.","category":"section"},{"location":"mathematical_background/#Overview-of-the-Bayesian-Framework","page":"Mathematical Background","title":"Overview of the Bayesian Framework","text":"","category":"section"},{"location":"mathematical_background/#The-Multiple-Evidence-Problem","page":"Mathematical Background","title":"The Multiple Evidence Problem","text":"Identifying true protein interactions requires distinguishing genuine interactors from:\n\nNon-specific binders (proteins that bind regardless of bait)\nContaminants (proteins present in controls)\nFalse positives due to experimental noise\n\nBayesInteractomics addresses this by evaluating three independent but complementary questions for each candidate protein:\n\nDetection: Is the protein consistently detected in samples versus controls?\nEnrichment: Is the protein quantitatively enriched in samples?\nCorrelation: Does the protein's abundance correlate with bait levels?\n\nEach question is answered using a Bayesian model that produces a Bayes factor quantifying the evidence for interaction. These Bayes factors are then combined using copula-based mixture models.","category":"section"},{"location":"mathematical_background/#Bayes-Factors","page":"Mathematical Background","title":"Bayes Factors","text":"A Bayes factor compares the evidence for two hypotheses:\n\nBF_10 = fracP(D  H_1)P(D  H_0) = fractextEvidence for  H_1textEvidence for  H_0\n\nwhere H_1 is the hypothesis of genuine interaction, H_0 is the null hypothesis (no interaction), and D is the observed data.\n\nInterpretation:\n\nCondition Interpretation\nBF_10  1 Data favor interaction\nBF_10 = 1 Data equally support both hypotheses\nBF_10  1 Data favor null hypothesis\nBF_10  10 Strong evidence for interaction\nBF_10  100 Very strong evidence for interaction\n\nBayes factors provide a continuous measure of evidence that naturally accounts for uncertainty and doesn't require arbitrary significance thresholds.","category":"section"},{"location":"mathematical_background/#Model-1:-Beta-Bernoulli-Model-(Detection-Probability)","page":"Mathematical Background","title":"Model 1: Beta-Bernoulli Model (Detection Probability)","text":"","category":"section"},{"location":"mathematical_background/#Biological-Motivation","page":"Mathematical Background","title":"Biological Motivation","text":"Genuine interactors should be consistently detected in samples but rarely (or never) in negative controls. The Beta-Bernoulli model evaluates whether the detection rate (proportion of replicates where protein is detected) is higher in samples than controls.","category":"section"},{"location":"mathematical_background/#Model-Specification","page":"Mathematical Background","title":"Model Specification","text":"For a protein, let n_s be the number of sample replicates, n_c the number of control replicates, k_s the number of samples where the protein is detected, and k_c the number of controls where the protein is detected.\n\nWe model detection as Bernoulli trials:\n\nbeginaligned\nk_s sim textBinomial(n_s theta_s) \nk_c sim textBinomial(n_c theta_c)\nendaligned\n\nwhere theta_s and theta_c are the true detection rates in samples and controls, respectively.","category":"section"},{"location":"mathematical_background/#Prior-Distribution","page":"Mathematical Background","title":"Prior Distribution","text":"We use weakly informative Beta priors for both detection rates:\n\nbeginaligned\ntheta_s sim textBeta(3 3) \ntheta_c sim textBeta(3 3)\nendaligned\n\nThe Beta(3,3) prior is centered at 0.5 with moderate uncertainty, expressing weak prior belief that detection rates are neither very low nor very high.","category":"section"},{"location":"mathematical_background/#Posterior-Distribution","page":"Mathematical Background","title":"Posterior Distribution","text":"Due to conjugacy of the Beta-Binomial model, posteriors are analytical:\n\nbeginaligned\ntheta_s  D sim textBeta(3 + k_s 3 + (n_s - k_s)) \ntheta_c  D sim textBeta(3 + k_c 3 + (n_c - k_c))\nendaligned","category":"section"},{"location":"mathematical_background/#Bayes-Factor-Computation","page":"Mathematical Background","title":"Bayes Factor Computation","text":"We test the one-sided hypothesis H_1colon theta_s  theta_c (detection rate higher in samples) against H_0colon theta_s leq theta_c (detection rate not higher).\n\nThe posterior probability is estimated via Monte Carlo:\n\np = P(theta_s  theta_c  D) = frac1N sum_i=1^N mathbb1theta_s^(i)  theta_c^(i)\n\nwhere theta_s^(i) and theta_c^(i) are samples from the posterior distributions.\n\nThe Bayes factor is computed from posterior and prior odds:\n\nBF_10 = fracp  (1-p)05  05 = fracp1-p\n\nThe prior odds are 1:1 (uniform prior on H_0 vs H_1).","category":"section"},{"location":"mathematical_background/#Implementation-Notes","page":"Mathematical Background","title":"Implementation Notes","text":"Monte Carlo estimation uses N = 10^7 samples for high precision\nDetection is defined as non-missing observation in the data matrix\nMissing data are naturally handled (not counted as detection)","category":"section"},{"location":"mathematical_background/#Model-2:-Hierarchical-Bayesian-Model-(Enrichment)","page":"Mathematical Background","title":"Model 2: Hierarchical Bayesian Model (Enrichment)","text":"","category":"section"},{"location":"mathematical_background/#Biological-Motivation-2","page":"Mathematical Background","title":"Biological Motivation","text":"Genuine interactors should show quantitative enrichment in samples compared to controls. The Hierarchical Bayesian Model (HBM) estimates the log2 fold change (log2FC) while accounting for:\n\nProtocol-level heterogeneity (different experimental methods)\nExperiment-level batch effects\nMissing data across replicates","category":"section"},{"location":"mathematical_background/#Model-Specification-2","page":"Mathematical Background","title":"Model Specification","text":"Let y_pej denote the log-transformed intensity for protocol p in 1 ldots P, experiment e in 1 ldots E_p within protocol p, and sample j (either control or bait).","category":"section"},{"location":"mathematical_background/#Likelihood","page":"Mathematical Background","title":"Likelihood","text":"y_pej  mu_pe sigma^2_pe sim mathcalN(mu_pe sigma^2_pe)\n\nwhere mu_pe is the mean intensity and sigma^2_pe is the variance for experiment e in protocol p.","category":"section"},{"location":"mathematical_background/#Hierarchical-Structure","page":"Mathematical Background","title":"Hierarchical Structure","text":"Protocol-level parameters (shared across experiments within a protocol):\n\nbeginaligned\nmu_pe^textcontrol  mu_p^0 tau_p^2 sim mathcalN(mu_p^0 tau_p^2) \nmu_pe^textsample  mu_p^0 log_2 FC_p tau_p^2 sim mathcalN(mu_p^0 + log_2 FC_p tau_p^2)\nendaligned\n\nwhere mu_p^0 is the baseline intensity for protocol p, log_2 FC_p is the log2 fold change for protocol p (parameter of interest), and tau_p^2 is the between-experiment variance within protocol p.\n\nExperiment-level variance:\n\nsigma^2_pe sim textInverseGamma(alpha_sigma beta_sigma)","category":"section"},{"location":"mathematical_background/#Priors","page":"Mathematical Background","title":"Priors","text":"Log2 fold change (weakly informative):\n\nlog_2 FC_p sim mathcalN(0 10)\n\nBaseline intensity:\n\nmu_p^0 = frac1E_p sum_e=1^E_p bary_pe^textcontrol\n\nwhere bary_pe^textcontrol is the empirical mean of control samples.\n\nBetween-experiment variance:\n\ntau_p^2 = maxleft(sigma_p^2 - barsigma^2_pe epsilonright)\n\nwhere sigma_p^2 is the empirical variance of experiment means, barsigma^2_pe is the average within-experiment variance, and epsilon = 10^-6 prevents numerical issues.\n\nWithin-experiment variance (conjugate prior):\n\nalpha_sigma = 2 quad beta_sigma = 05","category":"section"},{"location":"mathematical_background/#Inference","page":"Mathematical Background","title":"Inference","text":"Posterior inference is performed using variational Bayes via RxInfer.jl, which approximates the posterior through optimization rather than sampling. This provides:\n\nFast convergence (seconds per protein)\nAutomatic convergence diagnostics\nFull posterior distributions for all parameters","category":"section"},{"location":"mathematical_background/#Bayes-Factor-Computation-2","page":"Mathematical Background","title":"Bayes Factor Computation","text":"The Bayes factor for enrichment tests H_1colon log_2 FC_p  0 (enrichment in samples) against H_0colon log_2 FC_p leq 0 (no enrichment).\n\nFrom the posterior distribution q(log_2 FC_p  D):\n\nBF_10 = fracP(log_2 FC_p  0  D)P(log_2 FC_p leq 0  D) = fracp1-p\n\nwhere p = int_0^infty q(log_2 FC_p  D)  d(log_2 FC_p).","category":"section"},{"location":"mathematical_background/#Multiple-Protocols","page":"Mathematical Background","title":"Multiple Protocols","text":"For datasets with multiple protocols, we obtain protocol-specific Bayes factors BF_1 BF_2 ldots BF_P. The overall enrichment Bayes factor is:\n\nBF_textenrichment = prod_p=1^P BF_p\n\nThis assumes conditional independence of protocols given the hypothesis.","category":"section"},{"location":"mathematical_background/#Model-3:-Bayesian-Linear-Regression-(Dose-Response-Correlation)","page":"Mathematical Background","title":"Model 3: Bayesian Linear Regression (Dose-Response Correlation)","text":"","category":"section"},{"location":"mathematical_background/#Biological-Motivation-3","page":"Mathematical Background","title":"Biological Motivation","text":"Genuine interactors often show a dose-response relationship: their abundance correlates with the bait protein's abundance. If bait expression varies across samples (e.g., due to transfection efficiency), true interactors should track these variations, while contaminants should not.","category":"section"},{"location":"mathematical_background/#Model-Specification-(Normal-Likelihood)","page":"Mathematical Background","title":"Model Specification (Normal Likelihood)","text":"Let y_i be the candidate protein intensity in sample i, x_i the bait protein (reference) intensity in sample i, and i in 1 ldots N the sample indices.","category":"section"},{"location":"mathematical_background/#Likelihood-2","page":"Mathematical Background","title":"Likelihood","text":"y_i  beta_0 beta_1 sigma^2 sim mathcalN(beta_0 + beta_1 x_i sigma^2)\n\nwhere beta_0 is the intercept, beta_1 is the slope (correlation strength — parameter of interest), and sigma^2 is the residual variance.","category":"section"},{"location":"mathematical_background/#Priors-2","page":"Mathematical Background","title":"Priors","text":"Slope (weakly informative):\n\nbeta_1 sim mathcalN(0 10)\n\nIntercept (weakly informative):\n\nbeta_0 sim mathcalN(0 100)\n\nResidual variance (conjugate):\n\nsigma^2 sim textInverseGamma(2 05)","category":"section"},{"location":"mathematical_background/#Hierarchical-Extension-for-Multiple-Protocols","page":"Mathematical Background","title":"Hierarchical Extension for Multiple Protocols","text":"When multiple protocols are present, we use protocol-specific slopes beta_1p with a hierarchical structure:\n\nbeta_1p  mu_beta tau_beta^2 sim mathcalN(mu_beta tau_beta^2)\n\nwhere mu_beta is the population mean slope (overall correlation) and tau_beta^2 is the between-protocol variance in slopes.\n\nHyperpriors:\n\nbeginaligned\nmu_beta sim mathcalN(0 10) \ntau_beta^2 sim textGamma(1 1)\nendaligned","category":"section"},{"location":"mathematical_background/#Inference-2","page":"Mathematical Background","title":"Inference","text":"Posterior inference uses variational Bayes via RxInfer.jl, yielding posterior distributions for all parameters.","category":"section"},{"location":"mathematical_background/#Bayes-Factor-Computation-3","page":"Mathematical Background","title":"Bayes Factor Computation","text":"The Bayes factor tests H_1colon beta_1  0 (positive correlation with bait) against H_0colon beta_1 leq 0 (no positive correlation).\n\nBF_10 = fracP(beta_1  0  D)P(beta_1 leq 0  D) = fracp1-p\n\nwhere p is computed from the posterior distribution.\n\nFor multiple protocols:\n\nBF_textcorrelation = prod_p=1^P BF_p","category":"section"},{"location":"mathematical_background/#Robust-Extension:-Student-t-via-Scale-Mixture","page":"Mathematical Background","title":"Robust Extension: Student-t via Scale Mixture","text":"The standard Normal likelihood assumes homogeneous residual variance, making the regression sensitive to outliers. Proteomics data frequently contain aberrant intensity values caused by misidentifications, interference, or carry-over. A robust regression replaces the Normal likelihood with a heavier-tailed Student-t distribution, implemented through a Normal–Gamma scale mixture that is fully compatible with variational message passing.","category":"section"},{"location":"mathematical_background/#Scale-Mixture-Representation","page":"Mathematical Background","title":"Scale-Mixture Representation","text":"Each observation receives its own precision tau_i, drawn from a Gamma distribution:\n\nbeginaligned\ntau_i sim textGammaleft(fracnu2 textscale = fractau_textbasenu2right) quad mathbbEtau_i = tau_textbase \ny_i mid mu_i tau_i sim mathcalN(mu_i textprecision = tau_i)\nendaligned\n\nMarginalizing over tau_i recovers a Student-t distribution:\n\ny_i mid mu_i sim textStudent-tleft(nu mu_i tau_textbaseright)\n\nThe degrees-of-freedom parameter nu controls tail heaviness: smaller nu yields heavier tails and greater outlier robustness; as nu to infty the model reduces to Normal regression.","category":"section"},{"location":"mathematical_background/#Hierarchical-Prior-Structure","page":"Mathematical Background","title":"Hierarchical Prior Structure","text":"The prior structure is identical to the Normal model. For the multi-protocol case:\n\nParameter Prior\nmu_alpha (hyper-mean intercept) mathcalN(0 (03196)^2)\nmu_beta (hyper-mean slope) mathcalN(hatmu_0 sigma_0^2)\nsigma_alpha (hyper-precision intercept) textGamma(6304 textscale=7932)\nsigma_beta (hyper-precision slope) textGamma(10 textscale=03)\nalpha_k (per-protocol intercept) mathcalN(mu_alpha textprecision=sigma_alpha)\nbeta_k (per-protocol slope) mathcalN(mu_beta textprecision=sigma_beta)\n\nThe empirical Bayes hyperparameters hatmu_0 and sigma_0^2 are estimated from OLS on the pooled data, identical to the Normal model.","category":"section"},{"location":"mathematical_background/#Empirical-Bayes-for-\\tau_{\\text{base}}","page":"Mathematical Background","title":"Empirical Bayes for tau_textbase","text":"The baseline precision is set to the inverse residual variance from an OLS fit:\n\ntau_textbase = frac1textVar(hatvarepsilon_textOLS)\n\nThis anchors the Student-t scale to the data, ensuring that mathbbEtau_i = tau_textbase matches the observed noise level.","category":"section"},{"location":"mathematical_background/#Default-Configuration","page":"Mathematical Background","title":"Default Configuration","text":"The degrees-of-freedom parameter defaults to nu = 5, which provides moderately heavy tails. When model comparison is enabled (see next section), nu is optimized over 3 50 by minimizing WAIC.","category":"section"},{"location":"mathematical_background/#Model-Comparison-via-WAIC","page":"Mathematical Background","title":"Model Comparison via WAIC","text":"The Widely Applicable Information Criterion (WAIC; Watanabe, 2010) provides a principled method for comparing the Normal and robust (Student-t) regression models. Unlike AIC or BIC, WAIC is fully Bayesian and uses the entire posterior distribution rather than a point estimate.","category":"section"},{"location":"mathematical_background/#WAIC-Definition","page":"Mathematical Background","title":"WAIC Definition","text":"Given S posterior draws theta^(1) ldots theta^(S) and n observations, WAIC is defined as:\n\ntextWAIC = -2left(textlppd - p_textwaicright)\n\nwhere the log pointwise predictive density and the effective number of parameters are:\n\nbeginaligned\ntextlppd = sum_i=1^n logleft(frac1S sum_s=1^S p(y_i mid theta^(s))right) \np_textwaic = sum_i=1^n textVar_sleft(log p(y_i mid theta^(s))right)\nendaligned\n\nLower WAIC indicates better out-of-sample predictive performance. The implementation uses S = 1000 posterior draws from the VMP approximate posteriors.","category":"section"},{"location":"mathematical_background/#Normal-vs-Robust-Regression-Comparison","page":"Mathematical Background","title":"Normal vs Robust Regression Comparison","text":"To compare the two regression models, we compute WAIC for each and take the difference:\n\nDeltatextWAIC = textWAIC_textnormal - textWAIC_textrobust\n\nA positive DeltatextWAIC favors the robust model (lower WAIC). The standard error of the difference is estimated from pointwise WAIC differences:\n\ntextSE_Delta = sqrtn cdot textVar(w_i^textnormal - w_i^textrobust)\n\nwhere w_i denotes the pointwise WAIC contribution of observation i. When DeltatextWAIC  2 cdot textSE_Delta, the difference is considered meaningful (Vehtari et al., 2017).","category":"section"},{"location":"mathematical_background/#Degrees-of-Freedom-Optimization","page":"Mathematical Background","title":"Degrees-of-Freedom Optimization","text":"When the robust model is selected, the degrees-of-freedom parameter nu can be optimized to minimize WAIC. BayesInteractomics uses Brent's method to search over nu in 3 50 with a tolerance of 0.5 (finer precision is not meaningful given WAIC uncertainty). A fixed random seed ensures a deterministic, smooth objective surface for the optimizer.\n\nThe optimization procedure:\n\nCompute WAIC for the Normal model once (baseline).\nFor each candidate nu, fit the robust model across all proteins and compute WAIC.\nReturn the nu that minimizes WAIC, along with the DeltatextWAIC relative to the Normal baseline.","category":"section"},{"location":"mathematical_background/#Evidence-Combination","page":"Mathematical Background","title":"Evidence Combination","text":"","category":"section"},{"location":"mathematical_background/#The-Combination-Problem","page":"Mathematical Background","title":"The Combination Problem","text":"We now have three Bayes factors for each protein: BF_textdetection (detection evidence), BF_textenrichment (enrichment evidence), and BF_textcorrelation (correlation evidence).\n\nThese are not independent: for example, enriched proteins are more likely to be consistently detected. Simple multiplication (independence assumption) would be incorrect.\n\nSolution: Model the joint distribution of Bayes factors using copulas, which flexibly capture dependencies while allowing arbitrary marginals. BayesInteractomics also provides a latent class model and Bayesian model averaging across both combination methods.","category":"section"},{"location":"mathematical_background/#Copula-Based-Combination","page":"Mathematical Background","title":"Copula-Based Combination","text":"","category":"section"},{"location":"mathematical_background/#Copula-Theory","page":"Mathematical Background","title":"Copula Theory","text":"A copula C is a multivariate distribution on 01^d with uniform marginals. By Sklar's theorem, any multivariate distribution F can be decomposed as:\n\nF(x_1 ldots x_d) = C(F_1(x_1) ldots F_d(x_d))\n\nwhere F_i are the marginal distributions and C is the copula capturing dependence.","category":"section"},{"location":"mathematical_background/#Mixture-Copula-Model","page":"Mathematical Background","title":"Mixture Copula Model","text":"The distribution of Bayes factors arises from a mixture of two populations:\n\nH_0 population: Non-interacting proteins (null hypothesis true)\nH_1 population: Genuine interactors (alternative hypothesis true)\n\nLet mathbfBF = (BF_textdetection BF_textenrichment BF_textcorrelation) be the triplet of Bayes factors.\n\nMixture model:\n\nF(mathbfBF) = pi_0 cdot F_H_0(mathbfBF) + pi_1 cdot F_H_1(mathbfBF)\n\nwhere pi_0 is the proportion of non-interactors, pi_1 = 1 - pi_0 is the proportion of true interactors, F_H_0 is the joint distribution under H_0 (modeled by copula C_0), and F_H_1 is the joint distribution under H_1 (modeled by copula C_1).\n\nCopula specification — for each component k in 0 1:\n\nF_H_k(mathbfBF) = C_kleft(G_1(BF_textdetection) G_2(BF_textenrichment) G_3(BF_textcorrelation)right)\n\nwhere C_k is the copula for component k (e.g., Clayton, Gumbel, Frank, Gaussian) and G_i is the marginal cumulative distribution for evidence type i.\n\nBayesInteractomics supports multiple copula families:\n\nClayton: Models lower tail dependence (joint low values)\nGumbel: Models upper tail dependence (joint high values)\nFrank: Symmetric dependence\nGaussian: Linear correlation structure\nJoe: Asymmetric upper tail dependence","category":"section"},{"location":"mathematical_background/#EM-Algorithm","page":"Mathematical Background","title":"EM Algorithm","text":"The mixture model parameters Theta = pi_0 pi_1 C_0 C_1 G_1 G_2 G_3 are estimated using the EM algorithm.\n\nE-Step — compute posterior probability that protein i belongs to H_1:\n\ngamma_i^(t) = fracpi_1^(t) cdot f_H_1(mathbfBF_i  Theta^(t))pi_0^(t) cdot f_H_0(mathbfBF_i  Theta^(t)) + pi_1^(t) cdot f_H_1(mathbfBF_i  Theta^(t))\n\nwhere f_H_k is the density corresponding to F_H_k.\n\nM-Step — update parameters to maximize expected complete-data log-likelihood:\n\nMixture weights:\n\npi_1^(t+1) = frac1N sum_i=1^N gamma_i^(t)\n\nCopula parameters: fit C_0 and C_1 using weighted data — C_0 is fit to proteins with weights (1 - gamma_i^(t)) and C_1 is fit to proteins with weights gamma_i^(t).\n\nMarginals: fit G_1 G_2 G_3 using kernel density estimation or empirical CDFs.\n\nInitialization:\n\nThe H_0 component is initialized using proteins with all Bayes factors < 1 (strong evidence against interaction)\nThe H_1 component is initialized using proteins with all Bayes factors > threshold (e.g., > 3)\nThe mixture weight is set to pi_1^(0) = 01 (conservative initial estimate)\n\nConvergence — iterate E-step and M-step until:\n\nfracpi_1^(t+1) - pi_1^(t)pi_1^(t)  epsilon\n\nTypically epsilon = 10^-4 and convergence occurs in 10–50 iterations.","category":"section"},{"location":"mathematical_background/#Combined-Bayes-Factor","page":"Mathematical Background","title":"Combined Bayes Factor","text":"After EM convergence, the combined Bayes factor for protein i is:\n\nBF_textcombinedi = fracf_H_1(mathbfBF_i)f_H_0(mathbfBF_i)\n\nThis is the likelihood ratio using the fitted copula densities.","category":"section"},{"location":"mathematical_background/#Posterior-Probability","page":"Mathematical Background","title":"Posterior Probability","text":"Assuming uniform prior P(H_1) = 05, the posterior probability of interaction is:\n\nP(H_1  mathbfBF_i) = fracBF_textcombinedi1 + BF_textcombinedi\n\nAlternatively, using the EM-estimated mixture proportion:\n\nP(H_1  mathbfBF_i) = gamma_i","category":"section"},{"location":"mathematical_background/#Latent-Class-Model","page":"Mathematical Background","title":"Latent Class Model","text":"The latent class model is a simpler alternative to copula-based combination that models the joint distribution of log-Bayes factors directly as a Gaussian mixture. It assumes conditional independence of the three evidence arms given the latent interaction status, which trades flexibility in dependence modeling for computational simplicity and robustness.","category":"section"},{"location":"mathematical_background/#Model-Specification-3","page":"Mathematical Background","title":"Model Specification","text":"Each protein has a latent class z_i in 0 1 indicating Background or Interaction status. The three-dimensional score vector mathbfs_i = (log BF_textenrichi log BF_textcorri log BF_textdetecti) is modeled as:\n\nbeginaligned\nz_i sim textCategorical(pi_0 pi_1) quad pi_0 + pi_1 = 1 \np(mathbfs_i mid z_i = k) = prod_d=1^3 mathcalN(s_id mid mu_dk sigma^2_dk)\nendaligned\n\nThe conditional independence assumption means that each evidence dimension contributes independently to the class assignment, given the latent state. This is a 2-component, 3-dimensional Gaussian mixture with diagonal covariance.","category":"section"},{"location":"mathematical_background/#Data-Preprocessing","page":"Mathematical Background","title":"Data Preprocessing","text":"Before EM fitting, Bayes factors are transformed and optionally winsorized:\n\nLog-transform: s_id = log(BF_id). Log-Bayes factors are approximately Normal by the CLT, with log(BF) = 0 representing no evidence.\nWinsorization (optional, default on): extreme values are clamped to the 1st and 99th percentiles. This protects the EM parameter estimates from extreme outliers. The original (non-winsorized) log-BFs are retained for posterior computation.","category":"section"},{"location":"mathematical_background/#EM-Algorithm-2","page":"Mathematical Background","title":"EM Algorithm","text":"The EM algorithm iterates between responsibility computation and parameter updates:\n\nE-Step — for each protein i, compute the posterior probability of belonging to the interaction class:\n\ngamma_i = fracpi_1 prod_d mathcalN(s_id mid mu_d1 sigma^2_d1)pi_0 prod_d mathcalN(s_id mid mu_d0 sigma^2_d0) + pi_1 prod_d mathcalN(s_id mid mu_d1 sigma^2_d1)\n\nM-Step — update parameters using the responsibilities:\n\nbeginaligned\npi_k^textnew = fracN_k + alpha_k - 1N + sum_j alpha_j - 2 quad N_k = sum_i gamma_ik \nmu_dk^textnew = fracsum_i gamma_ik  s_idN_k \nsigma_dk^textnew = maxleft(sqrtfracsum_i gamma_ik (s_id - mu_dk)^2N_k sigma_textfloorright)\nendaligned\n\nThe mixing weights receive a Dirichlet prior with boldsymbolalpha = (10 1), encoding a prior expectation that most proteins are non-interactors.\n\nLabel ordering constraint: after each M-step, if mu_textenrich1  mu_textenrich0, all parameters and responsibilities between the two components are swapped. This ensures the interaction class always has a higher mean enrichment score.\n\nConvergence: the algorithm terminates when the relative change in log-likelihood falls below 10^-6, or after a maximum of 100 iterations.","category":"section"},{"location":"mathematical_background/#Posterior-Computation-and-Monotonicity-Correction","page":"Mathematical Background","title":"Posterior Computation and Monotonicity Correction","text":"Final posteriors are computed on the original (non-winsorized) log-BF values using the EM-fitted parameters. A monotonicity correction prevents proteins with extremely strong evidence from being penalized:\n\nFor each dimension d, if s_id  mu_d1 (the protein's score exceeds the interaction-class mean), the per-dimension log-likelihood ratio is floored at zero:\n\ntextLLR_d = begincases\nlog fracmathcalN(s_id mid mu_d1 sigma^2_d1)mathcalN(s_id mid mu_d0 sigma^2_d0)  textif  s_id leq mu_d1 6pt\nmaxleft(log fracmathcalN(s_id mid mu_d1 sigma^2_d1)mathcalN(s_id mid mu_d0 sigma^2_d0) 0right)  textif  s_id  mu_d1\nendcases\n\nThe posterior probability is then:\n\nP(z_i = 1 mid mathbfs_i) = frac11 + expleft(-logfracpi_1pi_0 - sum_d textLLR_dright)","category":"section"},{"location":"mathematical_background/#Bayesian-Model-Averaging-(BMA)","page":"Mathematical Background","title":"Bayesian Model Averaging (BMA)","text":"When both copula and latent class combination methods are available, Bayesian Model Averaging (BMA) provides a principled way to combine their posterior probabilities, weighting each method by how well it fits the data.","category":"section"},{"location":"mathematical_background/#BIC-Computation-and-Model-Weights","page":"Mathematical Background","title":"BIC Computation and Model Weights","text":"The Bayesian Information Criterion approximates the log marginal likelihood for each combination model m:\n\ntextBIC_m = -2 log hatL_m + k_m log n\n\nwhere hatL_m is the maximized likelihood, k_m is the number of parameters, and n is the number of proteins.\n\nThe parameter counts are:\n\nModel Parameters Total k\nCopula copula dependence params + 6 (H0 marginals) + 6 (H1 marginals) + 1 (mixing weight) k_textcop + 13\nLatent class 2 classes times 3 dims times 2 (mu sigma) + 1 (mixing weight) 13\n\nModel weights are computed from BIC differences:\n\nw_m = fracexp(-tfrac12DeltatextBIC_m)sum_j exp(-tfrac12DeltatextBIC_j) quad DeltatextBIC_m = textBIC_m - min_j textBIC_j","category":"section"},{"location":"mathematical_background/#Averaged-Posterior","page":"Mathematical Background","title":"Averaged Posterior","text":"The model-averaged posterior probability for each protein is a weighted combination:\n\nP_textavg(H_1 mid D_i) = w_textcopula cdot P_textcopula(H_1 mid D_i) + w_textlc cdot P_textlc(H_1 mid D_i)\n\nThe averaged Bayes factor is derived from the averaged posterior:\n\nBF_textavgi = fracP_textavg  (1 - P_textavg)pi_1  pi_0\n\nwhere pi_1  pi_0 is the prior odds from the copula EM fit.","category":"section"},{"location":"mathematical_background/#Summary-Statistics","page":"Mathematical Background","title":"Summary Statistics","text":"For each protein, BayesInteractomics reports:","category":"section"},{"location":"mathematical_background/#Bayes-Factors-2","page":"Mathematical Background","title":"Bayes Factors","text":"Individual BFs from each model\nCombined BF from copula mixture\nLog BF for extremely large values","category":"section"},{"location":"mathematical_background/#Posterior-Summaries-for-log2FC","page":"Mathematical Background","title":"Posterior Summaries for log2FC","text":"Mean: mathbbElog_2 FC  D\nMedian: textmedian(log_2 FC  D)\nSD: Standard deviation (uncertainty)\nCredible intervals: 95% highest density intervals\nProbability of direction (pd): P(log_2 FC  0  D)\nROPE percentage: P(log_2 FC  epsilon  D) where epsilon is a practical equivalence threshold","category":"section"},{"location":"mathematical_background/#Probability-of-Direction-(pd)","page":"Mathematical Background","title":"Probability of Direction (pd)","text":"The probability of direction (also called Maximum Probability of Effect) quantifies the certainty about the sign of an effect. For a posterior distribution of the parameter theta:\n\nFrom posterior draws (S samples):\n\ntextpd = maxleft(frac1Ssum_s=1^S mathbb1theta^(s)  0 1 - frac1Ssum_s=1^S mathbb1theta^(s)  0right)\n\nFrom an analytical posterior (e.g., Normal or mixture):\n\ntextpd = maxleft(Phi(0) 1 - Phi(0)right)\n\nwhere Phi(0) is the CDF evaluated at zero.\n\nThe probability of direction is always in 05 10. A value of 0.5 indicates complete uncertainty about the direction, while 1.0 indicates certainty. The associated direction label is \"+\" if the effect is more likely positive, \"-\" if negative, or \"~\" if exactly 0.5.\n\nConversion to p-values (for compatibility with frequentist frameworks):\n\nConversion Formula\nTwo-sided p-value p = 2(1 - textpd)\nOne-sided p-value p = 1 - textpd","category":"section"},{"location":"mathematical_background/#Bayesian-FDR-q-values","page":"Mathematical Background","title":"Bayesian FDR q-values","text":"To control the false discovery rate in a Bayesian framework, BayesInteractomics computes q-values from the posterior probabilities. The local false discovery rate for protein i is:\n\ntextlfdr_i = 1 - P(H_1 mid D_i)\n\nProteins are sorted by descending posterior probability, and the q-value for the protein at rank i is the cumulative average of local false discovery rates up to that rank:\n\nq_i = frac1i sum_j=1^i textlfdr_(j)\n\nwhere (j) denotes the j-th protein in the sorted order. A protein with q_i  alpha means that among all proteins ranked at least as highly, the expected proportion of false discoveries is at most alpha.","category":"section"},{"location":"mathematical_background/#Convergence-Diagnostics","page":"Mathematical Background","title":"Convergence Diagnostics","text":"ESS (Effective Sample Size): Measures quality of posterior samples (should be > 400)\nRhat: Gelman-Rubin convergence diagnostic (should be < 1.01)","category":"section"},{"location":"mathematical_background/#Multiple-Imputation","page":"Mathematical Background","title":"Multiple Imputation","text":"Mass spectrometry data frequently contain missing values (missing not at random or missing at random). BayesInteractomics supports multiple imputation to propagate missing-data uncertainty into all downstream inferences.\n\nThe procedure follows Rubin's (1987) combining rules:\n\nGenerate M imputed datasets: Each imputed dataset fills in missing values from a plausible imputation model.\nFit the full model on each imputed dataset: The enrichment model (HBM) and regression model are run independently on each of the M datasets, yielding M posterior distributions per protein.\nPool posteriors as an equal-weight mixture: For each protein parameter theta, the pooled posterior is a mixture of the M individual posteriors:\n\nq_textpooled(theta) = frac1M sum_m=1^M q_m(theta)\n\nwhere q_m(theta) is the posterior from the m-th imputed dataset.\n\nCompute statistics on the mixture: Bayes factors, log2FC summaries, credible intervals, and all other summary statistics are computed from the pooled mixture distribution. This naturally incorporates both within-imputation uncertainty (each q_m has its own spread) and between-imputation uncertainty (the q_m may have different locations).","category":"section"},{"location":"mathematical_background/#Differential-Analysis","page":"Mathematical Background","title":"Differential Analysis","text":"BayesInteractomics provides a framework for comparing interaction profiles between two experimental conditions (e.g., wild-type vs. mutant, treated vs. untreated). For each protein present in both conditions, the analysis quantifies whether the interaction evidence differs.","category":"section"},{"location":"mathematical_background/#Differential-Bayes-Factor","page":"Mathematical Background","title":"Differential Bayes Factor","text":"The differential Bayes factor measures relative evidence between condition A and condition B:\n\ntextdBF_i = fracBF_iABF_iB\n\ncomputed in log-space as log_10(textdBF_i) = log_10(BF_iA) - log_10(BF_iB). A positive log_10(textdBF) indicates stronger interaction evidence in condition A. Both the combined Bayes factor and per-evidence Bayes factors (enrichment, correlation, detection) are compared, allowing diagnosis of which evidence arm drives the differential signal.","category":"section"},{"location":"mathematical_background/#Effect-Size-and-Differential-Posterior","page":"Mathematical Background","title":"Effect Size and Differential Posterior","text":"The effect size is the difference in mean log2 fold changes:\n\nDeltatextlog2FC_i = overlinetextlog2FC_iA - overlinetextlog2FC_iB\n\nThe differential posterior probability quantifies evidence for any difference (direction-agnostic):\n\nP(textdiff mid D_i) = fractextdBF_i1 + textdBF_i\n\nMultiple testing is controlled by computing Bayesian FDR q-values on the differential posteriors (see Bayesian FDR q-values above).","category":"section"},{"location":"mathematical_background/#Interaction-Classification","page":"Mathematical Background","title":"Interaction Classification","text":"Each protein is classified into one of five categories based on the differential evidence and configurable thresholds:\n\nClass Description\nGAINED Interaction is stronger or exclusively present in condition A\nREDUCED Interaction is stronger or exclusively present in condition B\nUNCHANGED No significant differential evidence\nBOTH_NEGATIVE Neither condition shows interaction, but differential q-value is significant\nCONDITION_SPECIFIC Protein detected in only one condition (appended as CONDITION_A_SPECIFIC or CONDITION_B_SPECIFIC)\n\nThree classification methods are available:\n\nPosterior: uses per-condition posterior probability thresholds and Deltatextlog2FC\ndBF: uses log_10(textdBF) exceeding a threshold\nCombined: requires both posterior and dBF criteria to hold simultaneously","category":"section"},{"location":"mathematical_background/#Computational-Implementation","page":"Mathematical Background","title":"Computational Implementation","text":"","category":"section"},{"location":"mathematical_background/#Parallelization","page":"Mathematical Background","title":"Parallelization","text":"BayesInteractomics exploits multi-core parallelism:\n\nProteins are analyzed independently in parallel using Julia's multi-threading\nEach thread writes results to a separate cache file to avoid contention\nResults are merged after all proteins complete","category":"section"},{"location":"mathematical_background/#Variational-Inference","page":"Mathematical Background","title":"Variational Inference","text":"RxInfer.jl uses variational message passing for fast Bayesian inference:\n\nFactorized approximation: q(theta) = prod_i q_i(theta_i)\nIterative message passing updates until convergence\nAutomatically handles missing data through marginalization","category":"section"},{"location":"mathematical_background/#Numerical-Stability","page":"Mathematical Background","title":"Numerical Stability","text":"Log-space computation for extreme Bayes factors\nRegularization of variance estimates (lower bound epsilon = 10^-6)\nRobust initialization for EM algorithm\nConvergence checks with maximum iteration limits","category":"section"},{"location":"mathematical_background/#References","page":"Mathematical Background","title":"References","text":"","category":"section"},{"location":"mathematical_background/#Bayesian-Inference","page":"Mathematical Background","title":"Bayesian Inference","text":"Gelman, A., et al. (2013). Bayesian Data Analysis, 3rd ed. Chapman & Hall/CRC.\nKruschke, J. K. (2014). Doing Bayesian Data Analysis, 2nd ed. Academic Press.","category":"section"},{"location":"mathematical_background/#Bayes-Factors-3","page":"Mathematical Background","title":"Bayes Factors","text":"Kass, R. E., & Raftery, A. E. (1995). Bayes factors. Journal of the American Statistical Association, 90(430), 773-795.\nRouder, J. N., et al. (2009). Bayesian t tests for accepting and rejecting the null hypothesis. Psychonomic Bulletin & Review, 16(2), 225-237.","category":"section"},{"location":"mathematical_background/#Hierarchical-Models","page":"Mathematical Background","title":"Hierarchical Models","text":"Gelman, A., & Hill, J. (2006). Data Analysis Using Regression and Multilevel/Hierarchical Models. Cambridge University Press.","category":"section"},{"location":"mathematical_background/#Robust-Regression","page":"Mathematical Background","title":"Robust Regression","text":"Lange, K. L., Little, R. J. A., & Taylor, J. M. G. (1989). Robust statistical modeling using the t distribution. Journal of the American Statistical Association, 84(408), 881-896.","category":"section"},{"location":"mathematical_background/#Model-Comparison","page":"Mathematical Background","title":"Model Comparison","text":"Watanabe, S. (2010). Asymptotic equivalence of Bayes cross validation and widely applicable information criterion in singular learning theory. Journal of Machine Learning Research, 11, 3571-3594.\nGelman, A., Hwang, J., & Vehtari, A. (2014). Understanding predictive information criteria for Bayesian models. Statistics and Computing, 24(6), 997-1016.\nVehtari, A., Gelman, A., & Gabry, J. (2017). Practical Bayesian model evaluation using leave-one-out cross-validation and WAIC. Statistics and Computing, 27(5), 1413-1432.","category":"section"},{"location":"mathematical_background/#Copula-Theory-2","page":"Mathematical Background","title":"Copula Theory","text":"Nelsen, R. B. (2006). An Introduction to Copulas, 2nd ed. Springer.\nJoe, H. (2014). Dependence Modeling with Copulas. Chapman & Hall/CRC.","category":"section"},{"location":"mathematical_background/#Mixture-Models-and-BMA","page":"Mathematical Background","title":"Mixture Models and BMA","text":"McLachlan, G. J., & Peel, D. (2000). Finite Mixture Models. Wiley.\nHoeting, J. A., Madigan, D., Raftery, A. E., & Volinsky, C. T. (1999). Bayesian model averaging: a tutorial. Statistical Science, 14(4), 382-417.","category":"section"},{"location":"mathematical_background/#Summary-Statistics-2","page":"Mathematical Background","title":"Summary Statistics","text":"Makowski, D., Ben-Shachar, M. S., Chen, S. H. A., & Lüdecke, D. (2019). Indices of effect existence and significance in the Bayesian framework. Frontiers in Psychology, 10, 2767.\nEfron, B., Tibshirani, R., Storey, J. D., & Tusher, V. (2001). Empirical Bayes analysis of a microarray experiment. Journal of the American Statistical Association, 96(456), 1151-1160.","category":"section"},{"location":"mathematical_background/#Multiple-Imputation-2","page":"Mathematical Background","title":"Multiple Imputation","text":"Rubin, D. B. (1987). Multiple Imputation for Nonresponse in Surveys. Wiley.","category":"section"},{"location":"mathematical_background/#Variational-Inference-2","page":"Mathematical Background","title":"Variational Inference","text":"Blei, D. M., et al. (2017). Variational inference: A review for statisticians. Journal of the American Statistical Association, 112(518), 859-877.\nBagaev, D., & de Vries, B. (2023). RxInfer: A Julia package for reactive message-passing-based Bayesian inference. Journal of Open Source Software, 8(84), 5161.","category":"section"},{"location":"mathematical_background/#Proteomics-Applications","page":"Mathematical Background","title":"Proteomics Applications","text":"Choi, H., et al. (2011). SAINT: Probabilistic scoring of affinity purification-mass spectrometry data. Nature Methods, 8(1), 70-73.\nMellacheruvu, D., et al. (2013). The CRAPome: A contaminant repository for affinity purification-mass spectrometry data. Nature Methods, 10(8), 730-736.","category":"section"},{"location":"differential_analysis/#Differential-Interaction-Analysis","page":"Differential Analysis","title":"Differential Interaction Analysis","text":"","category":"section"},{"location":"differential_analysis/#Overview","page":"Differential Analysis","title":"Overview","text":"BayesInteractomics supports differential interaction analysis — comparing protein interaction profiles between two experimental conditions (e.g., wild-type vs. mutant, treated vs. untreated). This module identifies interactions that are gained, lost, or unchanged between conditions.","category":"section"},{"location":"differential_analysis/#Quick-Start","page":"Differential Analysis","title":"Quick Start","text":"using BayesInteractomics\n\n# Option 1: From two CONFIG objects (end-to-end pipeline)\nconfig_wt = CONFIG(datafile=[\"wt.xlsx\"], ...)\nconfig_mut = CONFIG(datafile=[\"mut.xlsx\"], ...)\n\ndiff = differential_analysis(config_wt, config_mut,\n    condition_A = \"WT\",\n    condition_B = \"Mutant\",\n    config = DifferentialConfig(q_threshold = 0.05)\n)\n\n# Option 2: From pre-computed AnalysisResult objects\n_, result_wt = run_analysis(config_wt)\n_, result_mut = run_analysis(config_mut)\n\ndiff = differential_analysis(result_wt, result_mut,\n    condition_A = \"WT\",\n    condition_B = \"Mutant\"\n)","category":"section"},{"location":"differential_analysis/#Statistical-Methodology","page":"Differential Analysis","title":"Statistical Methodology","text":"For each protein present in both conditions, the module computes:","category":"section"},{"location":"differential_analysis/#1.-Differential-Bayes-Factor-(dBF)","page":"Differential Analysis","title":"1. Differential Bayes Factor (dBF)","text":"dBF = BF_A / BF_B\n\nA log₁₀(dBF) > 0 means stronger evidence for interaction in condition A.","category":"section"},{"location":"differential_analysis/#2.-Per-Evidence-Differential","page":"Differential Analysis","title":"2. Per-Evidence Differential","text":"The same ratio is computed separately for enrichment, correlation, and detection Bayes factors, allowing you to diagnose which evidence type drives the differential signal.","category":"section"},{"location":"differential_analysis/#3.-Effect-Size","page":"Differential Analysis","title":"3. Effect Size","text":"Δlog₂FC = mean_log₂FC_A − mean_log₂FC_B","category":"section"},{"location":"differential_analysis/#4.-Differential-Posterior-Probability","page":"Differential Analysis","title":"4. Differential Posterior Probability","text":"P(differential | data) = |dBF| / (1 + |dBF|)\n\nThis is a direction-agnostic measure of evidence for any difference.","category":"section"},{"location":"differential_analysis/#5.-Multiple-Testing-Correction","page":"Differential Analysis","title":"5. Multiple Testing Correction","text":"Bayesian FDR q-values are computed on the differential posterior probabilities.","category":"section"},{"location":"differential_analysis/#6.-Interaction-Classification","page":"Differential Analysis","title":"6. Interaction Classification","text":"Proteins are classified into categories based on the classification method:\n\nClass Meaning\nGAINED Interaction present in A but not in B (or stronger in A)\nREDUCED Interaction present in B but not in A (or stronger in B)\nUNCHANGED Similar interaction strength in both conditions\nBOTH_NEGATIVE Neither condition shows strong interaction evidence\nCONDITION_A_SPECIFIC Protein only detected in condition A\nCONDITION_B_SPECIFIC Protein only detected in condition B","category":"section"},{"location":"differential_analysis/#Configuration","page":"Differential Analysis","title":"Configuration","text":"DifferentialConfig(\n    # Significance thresholds\n    q_threshold = 0.05,                 # FDR threshold\n    dbf_threshold = 1.0,                # |log10(dBF)| threshold\n    delta_log2fc_threshold = 1.0,       # |Δlog2FC| threshold\n    posterior_threshold = 0.8,          # Min posterior for \"interactor\"\n\n    # Classification method\n    classification_method = :posterior,  # :posterior, :dbf, or :combined\n\n    # Output file paths\n    results_file = \"differential_results.xlsx\",\n    volcano_file = \"differential_volcano.png\",\n    evidence_file = \"differential_evidence.png\",\n    scatter_file = \"differential_scatter.png\",\n    classification_file = \"differential_classification.png\",\n    ma_file = \"differential_ma.png\",\n\n    # HTML report\n    generate_report_html = true\n)","category":"section"},{"location":"differential_analysis/#Classification-Methods","page":"Differential Analysis","title":"Classification Methods","text":":posterior (default): Uses per-condition posterior probabilities. A protein is an \"interactor\" if posterior > posterior_threshold. GAINED = interactor in A but not B with Δlog₂FC ≥ 0.\n:dbf: Uses |log₁₀(dBF)| > dbf_threshold directly.\n:combined: Both posterior and dBF criteria must be satisfied.","category":"section"},{"location":"differential_analysis/#Visualization","page":"Differential Analysis","title":"Visualization","text":"Five diagnostic plots are generated automatically:","category":"section"},{"location":"differential_analysis/#Volcano-Plot","page":"Differential Analysis","title":"Volcano Plot","text":"plt = differential_volcano_plot(diff)\n\n# Customization\nplt = differential_volcano_plot(diff,\n    x_axis = :delta_log2fc,     # or :log10_dbf (default)\n    y_axis = :differential_q,   # or :differential_posterior\n    x_clip = 4.0                # Fixed x-axis range\n)","category":"section"},{"location":"differential_analysis/#Evidence-Plot","page":"Differential Analysis","title":"Evidence Plot","text":"Four-panel plot showing per-evidence-type differential Bayes factors:\n\nplt = differential_evidence_plot(diff)","category":"section"},{"location":"differential_analysis/#Scatter-Plot","page":"Differential Analysis","title":"Scatter Plot","text":"Compare a metric between conditions:\n\nplt = differential_scatter_plot(diff, metric = :posterior_prob)\n# Also: :bf, :log2fc","category":"section"},{"location":"differential_analysis/#Classification-Plot","page":"Differential Analysis","title":"Classification Plot","text":"Bar chart summarizing the count of proteins in each class:\n\nplt = differential_classification_plot(diff)","category":"section"},{"location":"differential_analysis/#MA-Plot","page":"Differential Analysis","title":"MA Plot","text":"Detect systematic biases where differential enrichment correlates with overall abundance:\n\nplt = differential_ma_plot(diff)","category":"section"},{"location":"differential_analysis/#Accessing-Results","page":"Differential Analysis","title":"Accessing Results","text":"# Filter by classification\ngained = gained_interactions(diff)\nlost = lost_interactions(diff)\nunchanged = unchanged_interactions(diff)\n\n# Significant differential interactions (any direction)\nsig = significant_differential(diff, q_threshold = 0.01)\n\n# Export to Excel\nexport_differential(diff, \"results.xlsx\")\n\n# Access full results DataFrame\ndiff.results   # All proteins with statistics\ndiff.config    # Configuration used\ndiff.n_gained  # Count summaries","category":"section"},{"location":"differential_analysis/#API-Reference","page":"Differential Analysis","title":"API Reference","text":"","category":"section"},{"location":"differential_analysis/#BayesInteractomics.differential_analysis","page":"Differential Analysis","title":"BayesInteractomics.differential_analysis","text":"differential_analysis(result_A, result_B; condition_A, condition_B, config)\n\nCompare interaction profiles between two experimental conditions.\n\nTakes two AnalysisResult objects (one per condition) and computes differential Bayes factors, posterior probabilities, and interaction classifications for each protein present in either condition.\n\nArguments\n\nresult_A::AbstractAnalysisResult: Results from condition A (e.g., wild-type)\nresult_B::AbstractAnalysisResult: Results from condition B (e.g., mutant)\n\nKeywords\n\ncondition_A::String = \"Condition_A\": Human-readable label for condition A\ncondition_B::String = \"Condition_B\": Human-readable label for condition B\nconfig::DifferentialConfig = DifferentialConfig(): Analysis configuration\n\nReturns\n\nDifferentialResult: Complete differential analysis results\n\nStatistical Methodology\n\nFor each protein present in both conditions (inner join on Protein ID):\n\nDifferential Bayes Factor (dBF): BF_A / BF_B (log-space subtraction). Positive log10(dBF) means stronger evidence for interaction in condition A.\nPer-evidence differential: Same ratio for enrichment, correlation, and detection BFs separately — diagnoses which evidence drives the signal.\nEffect size: delta_log2FC = mean_log2FC_A - mean_log2FC_B.\nDifferential posterior: P(diff | data) = |dBF| / (1 + |dBF|). Direction-agnostic measure of evidence for any difference.\nMultiple testing: Bayesian FDR q-values on differential posteriors.\nClassification: GAINED, REDUCED, UNCHANGED, or BOTH_NEGATIVE based on config method.\n\nProteins found in only one condition are appended as CONDITION_A_SPECIFIC or CONDITION_B_SPECIFIC with NaN fill for the missing condition.\n\nExamples\n\nresult_wt = run_analysis(config_wt)[2]\nresult_mut = run_analysis(config_mut)[2]\n\ndiff = differential_analysis(result_wt, result_mut,\n    condition_A = \"WT\",\n    condition_B = \"Mutant\",\n    config = DifferentialConfig(q_threshold = 0.01))\n\nprintln(diff)\ngained = gained_interactions(diff)\n\nSee also: DifferentialResult, DifferentialConfig\n\n\n\n\n\ndifferential_analysis(config_A, config_B; condition_A, condition_B, config, scatter_metric)\n\nEnd-to-end differential interaction analysis pipeline.\n\nRuns run_analysis on both CONFIG objects, compares the resulting interaction profiles, generates diagnostic plots (volcano, evidence, scatter), and exports results to an Excel file.\n\nArguments\n\nconfig_A::CONFIG: Analysis configuration for condition A\nconfig_B::CONFIG: Analysis configuration for condition B\n\nKeywords\n\ncondition_A::String = \"Condition_A\": Human-readable label for condition A\ncondition_B::String = \"Condition_B\": Human-readable label for condition B\nconfig::DifferentialConfig = DifferentialConfig(): Differential analysis parameters and output paths (see DifferentialConfig)\nscatter_metric::Symbol = :posterior_prob: Metric for the scatter plot (:posterior_prob, :bf, or :log2fc)\n\nReturns\n\nDifferentialResult: Complete differential analysis results\n\nSide Effects\n\nSaves volcano plot to config.volcano_file\nSaves evidence plot to config.evidence_file\nSaves scatter plot to config.scatter_file\nSaves results Excel to config.results_file\n\nExamples\n\nconfig_wt = CONFIG(datafile=[\"wt.xlsx\"], ...)\nconfig_mut = CONFIG(datafile=[\"mut.xlsx\"], ...)\n\ndiff = differential_analysis(config_wt, config_mut,\n    condition_A = \"WT\",\n    condition_B = \"Mutant\",\n    config = DifferentialConfig(\n        q_threshold = 0.01,\n        volcano_file = \"results/volcano.svg\",\n        results_file = \"results/differential.xlsx\"\n    ))\n\nSee also: DifferentialConfig, DifferentialResult, run_analysis\n\n\n\n\n\ndifferential_analysis(config_A, config_B, imputed_data_A, raw_data_A, imputed_data_B, raw_data_B; ...)\n\nEnd-to-end differential interaction analysis pipeline with multiple imputation support.\n\nRuns run_analysis with imputed datasets on both conditions, compares the resulting interaction profiles, generates diagnostic plots (volcano, evidence, scatter), and exports results to an Excel file.\n\nArguments\n\nconfig_A::CONFIG: Analysis configuration for condition A\nconfig_B::CONFIG: Analysis configuration for condition B\nimputed_data_A::Vector{InteractionData}: Imputed datasets for condition A\nraw_data_A::InteractionData: Raw (non-imputed) data for condition A (used for Beta-Bernoulli)\nimputed_data_B::Vector{InteractionData}: Imputed datasets for condition B\nraw_data_B::InteractionData: Raw (non-imputed) data for condition B (used for Beta-Bernoulli)\n\nKeywords\n\ncondition_A::String = \"Condition_A\": Human-readable label for condition A\ncondition_B::String = \"Condition_B\": Human-readable label for condition B\nconfig::DifferentialConfig = DifferentialConfig(): Differential analysis parameters and output paths (see DifferentialConfig)\nscatter_metric::Symbol = :posterior_prob: Metric for the scatter plot (:posterior_prob, :bf, or :log2fc)\n\nReturns\n\nDifferentialResult: Complete differential analysis results\n\nSide Effects\n\nSaves individual analysis outputs as configured in config_A and config_B\nSaves volcano plot to config.volcano_file\nSaves evidence plot to config.evidence_file\nSaves scatter plot to config.scatter_file\nSaves results Excel to config.results_file\n\nExamples\n\nconfig_wt  = CONFIG(datafile=[\"wt.xlsx\"], ...)\nconfig_mut = CONFIG(datafile=[\"mut.xlsx\"], ...)\n\ndiff = differential_analysis(config_wt, config_mut,\n    wt_imputed, wt_raw, mut_imputed, mut_raw,\n    condition_A = \"WT\",\n    condition_B = \"Mutant\",\n    config = DifferentialConfig(\n        q_threshold = 0.01,\n        volcano_file = \"results/volcano.svg\",\n        results_file = \"results/differential.xlsx\"\n    ))\n\nSee also: DifferentialConfig, DifferentialResult, run_analysis\n\n\n\n\n\n","category":"function"},{"location":"differential_analysis/#BayesInteractomics.DifferentialConfig","page":"Differential Analysis","title":"BayesInteractomics.DifferentialConfig","text":"DifferentialConfig\n\nConfiguration for differential interaction analysis.\n\nStatistical Thresholds\n\nposterior_threshold::Float64: Minimum posterior probability to consider a protein as a true interactor in a given condition (default: 0.8)\nq_threshold::Float64: Maximum q-value (BFDR) for significance in differential analysis (default: 0.05)\ndelta_log2fc_threshold::Float64: Minimum absolute difference in mean_log2FC to classify as gained/lost when both conditions show interaction (default: 1.0)\ndbf_threshold::Float64: Minimum absolute log10 differential Bayes factor to classify as gained/lost (default: 1.0, i.e., 10-fold BF difference)\nclassification_method::Symbol: Method for classifying interactions:\n:posterior (default): use posterior probability thresholds\n:dbf: use differential Bayes factor thresholds\n:combined: require both posterior and dBF criteria\n\nOutput Paths (used by the pipeline method differential_analysis(config_a, config_b))\n\nresults_file::String: Path for the differential results Excel file (default: \"differential_results.xlsx\")\nvolcano_file::String: Path for the volcano plot image (default: \"differential_volcano.png\")\nevidence_file::String: Path for the evidence plot image (default: \"differential_evidence.png\")\nscatter_file::String: Path for the scatter plot image (default: \"differential_scatter.png\")\nclassification_file::String: Path for the classification bar chart (default: \"differential_classification.png\")\nma_file::String: Path for the MA plot (default: \"differential_ma.png\")\ngenerate_report_html::Bool: Automatically generate an interactive HTML report after analysis (default: true)\n\nExamples\n\n# Default configuration\nconfig = DifferentialConfig()\n\n# Stringent thresholds with custom output paths\nconfig = DifferentialConfig(\n    posterior_threshold = 0.95,\n    q_threshold = 0.01,\n    classification_method = :combined,\n    results_file = \"results/diff.xlsx\",\n    volcano_file = \"results/volcano.svg\"\n)\n\n\n\n\n\n","category":"type"},{"location":"differential_analysis/#BayesInteractomics.DifferentialResult","page":"Differential Analysis","title":"BayesInteractomics.DifferentialResult","text":"DifferentialResult\n\nComplete results from a differential interaction analysis comparing two conditions.\n\nFields\n\nResult DataFrame\n\nresults::DataFrame: Per-protein differential statistics. Columns: Protein, bf_A, bf_B, dbf, log10_dbf, posterior_A, posterior_B, delta_posterior, q_A, q_B, log2fc_A, log2fc_B, delta_log2fc, bf_enrichment_A, bf_enrichment_B, dbf_enrichment, bf_correlation_A, bf_correlation_B, dbf_correlation, bf_detected_A, bf_detected_B, dbf_detected, differential_posterior, differential_q, classification\n\nCondition labels\n\ncondition_A::String: Label for condition A\ncondition_B::String: Label for condition B\n\nConfiguration\n\nconfig::DifferentialConfig: Configuration used for this analysis\n\nMetadata\n\nn_proteins_A::Int: Number of proteins in condition A\nn_proteins_B::Int: Number of proteins in condition B\nn_shared::Int: Number of shared proteins (inner join)\nn_condition_A_specific::Int: Proteins only in condition A\nn_condition_B_specific::Int: Proteins only in condition B\ntimestamp::DateTime: When analysis was performed\n\nSummary counts\n\nn_gained::Int: Interactions gained (stronger in condition A)\nn_reduced::Int: Interactions reduced (stronger in condition B)\nn_unchanged::Int: Interactions unchanged between conditions\nn_both_negative::Int: Proteins not detected in either condition but with significant differential evidence\n\nIterator Interface\n\nIterates over (protein_name, row_data) tuples.\n\nIndexing\n\ndiff[i]: Get row i from results (Integer indexing)\ndiff[protein]: Get row for specific protein (String indexing)\n\nExamples\n\ndiff = differential_analysis(result_wt, result_mut,\n    condition_A = \"WT\", condition_B = \"Mutant\")\n\n# Summary\nprintln(diff)\n\n# Iterate\nfor (protein, row) in diff\n    if row.classification == GAINED\n        println(\"$protein gained in WT\")\n    end\nend\n\n# Index\nrow = diff[\"MYC\"]\nprintln(\"dBF: \", row.dbf)\n\nSee also: differential_analysis, DifferentialConfig, InteractionClass\n\n\n\n\n\n","category":"type"},{"location":"differential_analysis/#BayesInteractomics.InteractionClass","page":"Differential Analysis","title":"BayesInteractomics.InteractionClass","text":"InteractionClass\n\nEnum classifying the differential interaction status of a protein.\n\nValues\n\nGAINED: Interaction significantly stronger in condition A than B (PPA ≥ threshold, PPB < threshold, Δlog₂FC ≥ 0)\nREDUCED: Interaction significantly stronger in condition B than A (PPB ≥ threshold, PPA < threshold, Δlog₂FC ≤ 0)\nUNCHANGED: Both conditions show interaction; no significant directional difference, or ambiguous evidence\nBOTH_NEGATIVE: Neither condition detects interaction (PP below threshold), but differential evidence is significant\nCONDITION_A_SPECIFIC: Protein detected only in condition A results\nCONDITION_B_SPECIFIC: Protein detected only in condition B results\n\n\n\n\n\n","category":"type"},{"location":"differential_analysis/#BayesInteractomics.gained_interactions","page":"Differential Analysis","title":"BayesInteractomics.gained_interactions","text":"gained_interactions(diff::DifferentialResult) -> DataFrame\n\nReturn only gained interactions (stronger in condition A).\n\n\n\n\n\n","category":"function"},{"location":"differential_analysis/#BayesInteractomics.lost_interactions","page":"Differential Analysis","title":"BayesInteractomics.lost_interactions","text":"lost_interactions(diff::DifferentialResult) -> DataFrame\n\nReturn only reduced interactions (stronger in condition B).\n\n\n\n\n\n","category":"function"},{"location":"differential_analysis/#BayesInteractomics.unchanged_interactions","page":"Differential Analysis","title":"BayesInteractomics.unchanged_interactions","text":"unchanged_interactions(diff::DifferentialResult) -> DataFrame\n\nReturn only unchanged interactions.\n\n\n\n\n\n","category":"function"},{"location":"differential_analysis/#BayesInteractomics.significant_differential","page":"Differential Analysis","title":"BayesInteractomics.significant_differential","text":"significant_differential(diff::DifferentialResult; q_threshold=0.05) -> DataFrame\n\nReturn all proteins with significant differential interaction evidence.\n\n\n\n\n\n","category":"function"},{"location":"differential_analysis/#BayesInteractomics.export_differential","page":"Differential Analysis","title":"BayesInteractomics.export_differential","text":"export_differential(diff::DifferentialResult, filepath::String)\n\nExport differential analysis results to an Excel file.\n\nCreates two sheets:\n\n\"differential\": Full results DataFrame (classification as strings)\n\"summary\": Summary statistics and configuration parameters\n\n\n\n\n\n","category":"function"},{"location":"differential_analysis/#BayesInteractomics.differential_volcano_plot","page":"Differential Analysis","title":"BayesInteractomics.differential_volcano_plot","text":"differential_volcano_plot(diff::DifferentialResult; kwargs...)\n\nCreate a volcano plot for differential interaction analysis.\n\nKeywords\n\nx_axis::Symbol = :log10_dbf: X-axis metric (:log10_dbf or :delta_log2fc)\ny_axis::Symbol = :differential_q: Y-axis metric (:differential_q → -log10(q), or :differential_posterior)\nlegend_pos::Symbol = :topleft: Legend position\nx_clip::Union{Float64,Nothing} = nothing: X-axis half-width. When nothing (default), limits are set to the 0.5th–99.5th percentile of the data for a readable range. When a Float64, limits are (-x_clip, x_clip). Points outside the limits are shown with triangular markers at the boundary so they remain visible.\n\nReturns\n\nA StatsPlots plot object. Points colored by classification: green = GAINED, red = REDUCED, grey = UNCHANGED.\n\nExamples\n\ndiff = differential_analysis(result_wt, result_mut)\nplt = differential_volcano_plot(diff)\nStatsPlots.savefig(plt, \"differential_volcano.png\")\n\n# Use delta log2FC on x-axis\nplt2 = differential_volcano_plot(diff, x_axis = :delta_log2fc)\n\n# Fixed ±4 range\nplt3 = differential_volcano_plot(diff, x_clip = 4.0)\n\n\n\n\n\n","category":"function"},{"location":"differential_analysis/#BayesInteractomics.differential_evidence_plot","page":"Differential Analysis","title":"BayesInteractomics.differential_evidence_plot","text":"differential_evidence_plot(diff::DifferentialResult)\n\nCreate a 4-panel plot showing per-evidence-type differential Bayes factors.\n\nPanels:\n\nlog10(dBFenrichment) vs log10(dBFcorrelation)\nlog10(dBFenrichment) vs log10(dBFdetected)\nlog10(dBFcorrelation) vs log10(dBFdetected)\nDensity of log10(dBF_combined)\n\nAll scatter panels colored by classification (green/red/grey).\n\n\n\n\n\n","category":"function"},{"location":"differential_analysis/#BayesInteractomics.differential_scatter_plot","page":"Differential Analysis","title":"BayesInteractomics.differential_scatter_plot","text":"differential_scatter_plot(diff::DifferentialResult; metric=:posterior_prob)\n\nScatter plot comparing a metric between conditions A and B.\n\nKeywords\n\nmetric::Symbol: Which metric to compare:\n:posterior_prob (default): Posterior probabilities\n:bf: Combined Bayes factors (log10 scale)\n:log2fc: Mean log2 fold change\n\nPoints colored by classification with identity line.\n\n\n\n\n\n","category":"function"},{"location":"differential_analysis/#BayesInteractomics.differential_classification_plot","page":"Differential Analysis","title":"BayesInteractomics.differential_classification_plot","text":"differential_classification_plot(diff::DifferentialResult)\n\nHorizontal bar chart showing the count of proteins in each interaction class.\n\nBars are grouped as: GAINED, REDUCED, UNCHANGED, BOTH_NEGATIVE, condition-A-specific, condition-B-specific. Provides a quick sanity-check of the differential analysis at a glance.\n\nReturns\n\nA StatsPlots plot object.\n\n\n\n\n\n","category":"function"},{"location":"differential_analysis/#BayesInteractomics.differential_ma_plot","page":"Differential Analysis","title":"BayesInteractomics.differential_ma_plot","text":"differential_ma_plot(diff::DifferentialResult)\n\nMA-style plot for differential proteomics.\n\nx-axis: ½ (log2FCA + log2FCB) — mean log2 fold change (proxy for abundance)\ny-axis: Δlog2FC = log2FCA − log2FCB — differential effect size\nHorizontal reference line at y = 0\nPoints colored by classification (green = GAINED, red = REDUCED, grey = UNCHANGED)\n\nUseful for detecting systematic biases where differential enrichment correlates with overall enrichment level.\n\nReturns\n\nA StatsPlots plot object.\n\n\n\n\n\n","category":"function"},{"location":"data_curation/#Data-Curation-and-Quality-Control","page":"Data Curation","title":"Data Curation and Quality Control","text":"","category":"section"},{"location":"data_curation/#Overview","page":"Data Curation","title":"Overview","text":"Before running the Bayesian analysis, input data often requires curation to ensure protein identifiers are clean, unambiguous, and consistent. BayesInteractomics includes an automated curation pipeline that handles:\n\nContaminant removal: Filter out common MS contaminants (CON__, REV__)\nProtein group splitting: Expand semicolon-delimited protein groups into individual entries\nSynonym resolution: Query the STRING database to map protein names to canonical identifiers\nDuplicate merging: Merge rows that map to the same canonical protein\nBait tracking: Track the bait protein index through all curation steps","category":"section"},{"location":"data_curation/#Quick-Start","page":"Data Curation","title":"Quick Start","text":"Curation is enabled by default in load_data and run_analysis:\n\n# Curation is automatic when using load_data\ndata = load_data(\n    [\"experiment.xlsx\"],\n    sample_cols, control_cols,\n    curate = true,          # enabled by default\n    species = 9606,         # NCBI taxonomy ID (9606 = human)\n    bait_name = \"HTT\"       # track bait through curation\n)\n\n# Returns (InteractionData, bait_index) when bait_name is set\ndata, bait_idx = load_data([\"experiment.xlsx\"], sample_cols, control_cols,\n    bait_name = \"HTT\")","category":"section"},{"location":"data_curation/#Curation-Pipeline","page":"Data Curation","title":"Curation Pipeline","text":"","category":"section"},{"location":"data_curation/#Step-1:-Contaminant-Removal","page":"Data Curation","title":"Step 1: Contaminant Removal","text":"Removes rows whose protein ID starts with common contaminant prefixes:\n\n# Controlled via:\ncurate_remove_contaminants = true  # default\n\nRecognized prefixes: CON__, REV__, and other standard MaxQuant contaminant markers.","category":"section"},{"location":"data_curation/#Step-2:-Protein-Group-Splitting","page":"Data Curation","title":"Step 2: Protein Group Splitting","text":"Mass spectrometry software often reports protein groups (multiple protein IDs separated by delimiters). The curation pipeline splits these into individual entries:\n\n# Control the delimiter:\ncurate_delimiter = \";\"  # default\n\nEach protein in a group receives a copy of the original quantification data.","category":"section"},{"location":"data_curation/#Step-3:-Synonym-Resolution-via-STRING","page":"Data Curation","title":"Step 3: Synonym Resolution via STRING","text":"Protein names are resolved to canonical identifiers by querying the STRING protein-protein interaction database:\n\ncurate = true\nspecies = 9606          # Human (NCBI taxonomy ID)\n# Other common species: 10090 (mouse), 10116 (rat), 7227 (fly), 6239 (worm)\n\nResults are cached locally in .bayesinteractomics_cache/ to avoid repeated API calls.","category":"section"},{"location":"data_curation/#Step-4:-Duplicate-Merging","page":"Data Curation","title":"Step 4: Duplicate Merging","text":"After synonym resolution, multiple rows may map to the same canonical protein. These are merged using a configurable strategy:\n\ncurate_merge_strategy = :max   # Keep maximum value per cell (default)\n# Alternative: :mean           # Average values per cell\n\nWhen curate_interactive = true (default), the user is prompted to confirm each merge. Use curate_auto_approve to auto-approve merges where proteins share a common prefix:\n\ncurate_auto_approve = 3  # Auto-approve if first 3 characters match","category":"section"},{"location":"data_curation/#Curation-Reports","page":"Data Curation","title":"Curation Reports","text":"Every curation run produces a CurationReport that logs all actions taken:\n\n# Reports are saved automatically next to data files\n# Location: .bayesinteractomics_cache/<filename>_curation_report.jld2","category":"section"},{"location":"data_curation/#Replay-Mode","page":"Data Curation","title":"Replay Mode","text":"Re-run a previous curation without interactive prompts:\n\ndata = load_data([\"experiment.xlsx\"], sample_cols, control_cols,\n    curate_replay = \"path/to/curation_report.jld2\"\n)\n\nThis is useful for reproducible analyses and batch processing.","category":"section"},{"location":"data_curation/#Configuration-via-CONFIG","page":"Data Curation","title":"Configuration via CONFIG","text":"All curation parameters can be set in the CONFIG struct:\n\nconfig = CONFIG(\n    # ... other fields ...\n    curate = true,\n    species = 9606,\n    curate_interactive = true,\n    curate_merge_strategy = :max,\n    bait_name = \"HTT\",\n    curate_replay = nothing,\n    curate_remove_contaminants = true,\n    curate_delimiter = \";\",\n    curate_auto_approve = 0\n)","category":"section"},{"location":"data_curation/#Curation-Types","page":"Data Curation","title":"Curation Types","text":"","category":"section"},{"location":"data_curation/#Utility-Functions","page":"Data Curation","title":"Utility Functions","text":"","category":"section"},{"location":"data_curation/#BayesInteractomics.curate_proteins","page":"Data Curation","title":"BayesInteractomics.curate_proteins","text":"curate_proteins(df::DataFrame, id_col::Int; kwargs...) -> (DataFrame, CurationReport, Union{Int, Nothing})\n\nMain curation pipeline. Processes a raw proteomics DataFrame through:\n\nContaminant removal (CON, REV)\nProtein group splitting (semicolons)\nSTRING ID resolution (API + cache)\nMerge candidate identification\nInteractive merge confirmation (or replay from saved report)\nRow merging\nProtein renaming to canonical names\n\nKeyword Arguments\n\nspecies::Int=9606: NCBI taxonomy ID\ninteractive::Bool=true: Whether to prompt user for merge confirmation\ncache_dir::String=\"\": Directory for STRING API cache\nreplay_report::Union{Nothing,CurationReport}=nothing: Replay decisions from saved report\nmerge_strategy::Symbol=:max: How to combine data when merging (:max or :mean)\nbait_name::Union{Nothing,String}=nothing: Bait protein name for refID tracking\ndo_remove_contaminants::Bool=true: Whether to remove CON/REV entries\ndelimiter::String=\";\": Delimiter for protein groups\nauto_approve_threshold::Int=0: Auto-approve merges with shared prefix length\n\nReturns\n\n(curated_df, report, bait_index) where bait_index is the new position of the bait\n\n\n\n\n\n","category":"function"},{"location":"data_curation/#BayesInteractomics.CurationReport","page":"Data Curation","title":"BayesInteractomics.CurationReport","text":"CurationReport\n\nComplete record of a curation run. Saved as JLD2 (machine-readable) and CSV (human-readable). Can be loaded and replayed for deterministic re-runs.\n\nFields\n\nentries::Vector{CurationEntry}:       All curation actions taken\nmerge_decisions::Vector{MergeDecision}: All merge decisions (approved and rejected)\nspecies::Int:                         NCBI taxonomy ID used for STRING queries\nstring_api_version::String:           STRING API URL version (e.g., \"version-12-0\")\ndata_hash::UInt64:                    Hash of the original input data for replay validation\ntimestamp::DateTime:                  When this curation was performed\npackage_version::String:              BayesInteractomics version\nn_proteins_before::Int:               Number of protein rows before curation\nn_proteins_after::Int:                Number of protein rows after curation\nsummary::Dict{Symbol,Int}:            Counts — :splits, :merges, :removals, :unmapped, :kept, :renames\n\n\n\n\n\n","category":"type"},{"location":"data_curation/#BayesInteractomics.CurationEntry","page":"Data Curation","title":"BayesInteractomics.CurationEntry","text":"CurationEntry\n\nRecord of a single curation decision. Immutable for audit trail safety.\n\nFields\n\noriginal_name::String:          Original protein name/ID from the input data\ncanonical_name::String:         Canonical name after curation (STRING preferred name or original if unmapped)\ncanonical_id::String:           STRING ID (e.g., \"9606.ENSP00000479624\") or \"\" if unmapped\naction::CurationActionType:     Type of curation action performed\nreason::String:                 Human-readable explanation of the action\nuser_approved::Bool:            Whether user explicitly confirmed (interactive mode)\nsource_row_indices::Vector{Int}: Original DataFrame row indices involved\ngroup_id::Union{String,Nothing}: Original protein group identifier, if this entry came from splitting\nis_lead::Bool:                  Whether this is the lead protein in its group (first in group)\n\n\n\n\n\n","category":"type"},{"location":"data_curation/#BayesInteractomics.CurationActionType","page":"Data Curation","title":"BayesInteractomics.CurationActionType","text":"CurationActionType\n\nEnum describing the curation action taken for a protein entry.\n\nValues:\n\nCURATE_KEEP:     No change needed — protein retained as-is\nCURATE_SPLIT:    Protein group was split into individual rows\nCURATE_MERGE:    Multiple rows merged to single canonical ID\nCURATE_RENAME:   Name resolved to STRING preferred name\nCURATE_REMOVE:   Contaminant or decoy entry removed\nCURATE_UNMAPPED: Could not resolve in STRING DB\n\n\n\n\n\n","category":"type"},{"location":"data_curation/#BayesInteractomics.MergeCandidate","page":"Data Curation","title":"BayesInteractomics.MergeCandidate","text":"MergeCandidate\n\nA set of rows in the DataFrame that map to the same canonical STRING ID but have different original names. Presented to the user for merge confirmation.\n\nFields\n\nnames::Vector{String}:                All distinct protein names mapping to the same canonical ID\nstring_id::String:                    Canonical STRING identifier\npreferred_name::String:               STRING's preferred (official) gene symbol\nannotation::String:                   STRING protein function description\nrow_indices::Dict{String,Vector{Int}}: Maps each name to its row indices in the DataFrame\n\n\n\n\n\n","category":"type"},{"location":"data_curation/#BayesInteractomics.remove_contaminants","page":"Data Curation","title":"BayesInteractomics.remove_contaminants","text":"remove_contaminants(df::DataFrame, id_col::Int) -> (DataFrame, Vector{CurationEntry})\n\nRemove contaminant and decoy entries (CON, REV prefixes) from the DataFrame. Returns the filtered DataFrame and curation log entries for removed rows.\n\n\n\n\n\n","category":"function"},{"location":"data_curation/#BayesInteractomics.parse_protein_id","page":"Data Curation","title":"BayesInteractomics.parse_protein_id","text":"parse_protein_id(id::AbstractString) -> String\n\nParse a protein identifier, handling common formats:\n\nUniProt pipe format: sp|P04637|P53_HUMAN → P53_HUMAN\nUniProt accession with isoform: P12345-2 → P12345\nPlain gene symbol: returned as-is\n\n\n\n\n\n","category":"function"},{"location":"data_curation/#BayesInteractomics.split_protein_groups","page":"Data Curation","title":"BayesInteractomics.split_protein_groups","text":"split_protein_groups(df::DataFrame, id_col::Int; delimiter=\";\") -> (DataFrame, Vector{CurationEntry})\n\nSplit protein groups (e.g., \"RBFOX3;RBFOX2;RBFOX1\") into individual rows, duplicating all data columns. The first protein in each group is marked as lead.\n\nReturns the expanded DataFrame and curation log entries.\n\n\n\n\n\n","category":"function"},{"location":"model_fitting/#Model-Fitting","page":"Model Fitting","title":"Model Fitting","text":"","category":"section"},{"location":"model_fitting/#Overview","page":"Model Fitting","title":"Overview","text":"BayesInteractomics implements a comprehensive Bayesian framework for analyzing protein-protein interactions through three complementary statistical models. Each model extracts a different type of evidence from the experimental data.","category":"section"},{"location":"model_fitting/#Model-Components","page":"Model Fitting","title":"Model Components","text":"","category":"section"},{"location":"model_fitting/#Beta-Bernoulli-Detection-Model","page":"Model Fitting","title":"Beta-Bernoulli Detection Model","text":"The Beta-Bernoulli model addresses a fundamental challenge in AP-MS experiments: distinguishing genuine interactions from background contamination. It models protein detection as a Bernoulli process with Beta-distributed probability.\n\nKey idea: If a protein is a true interactor, it should be detected more consistently in samples than in controls.\n\nPrior: Beta(α, β) on detection probability\nLikelihood: Bernoulli observations (detected or not)\nPosterior: Updated Beta distribution\nBayes factor: Compares detection rate in samples vs. controls\n\n# Low-level usage (called automatically by analyse)\nbf, posterior_prob, prior_prob = betabernoulli(data, protein_idx, n_controls, n_samples)","category":"section"},{"location":"model_fitting/#Hierarchical-Bayesian-Model-(HBM)","page":"Model Fitting","title":"Hierarchical Bayesian Model (HBM)","text":"The HBM captures enrichment evidence through log₂ fold-change estimation:\n\nGlobal level: Overall effect across all protocols\nProtocol level: Protocol-specific effects (e.g., AP-MS vs. BioID)\nExperiment level: Per-experiment fold-change estimates\nInference: Variational Bayes via RxInfer\n\nKey advantages:\n\nBorrows strength across experiments through hierarchical structure\nHandles missing data naturally within the Bayesian framework\nProduces reliable estimates even with few replicates\nGenerates Bayes factors for the enrichment hypothesis","category":"section"},{"location":"model_fitting/#Bayesian-Linear-Regression","page":"Model Fitting","title":"Bayesian Linear Regression","text":"The regression model assesses dose-response relationships: does prey abundance correlate with bait abundance?\n\nStandard model:\n\ny = β₀ + β₁·x + ε,    where ε ~ Normal(0, σ²)\n\nRobust model (Student-t likelihood):\n\ny = β₀ + β₁·x + ε,    where ε ~ StudentT(ν, 0, σ²)\n\nThe robust variant uses a scale-mixture representation of the Student-t distribution, making it resistant to outliers. The degrees-of-freedom parameter ν can be optimized via WAIC.\n\n# Control regression model in CONFIG:\nregression_likelihood = :robust_t   # or :normal\nstudent_t_nu = 5.0                  # degrees of freedom\noptimize_nu = true                  # optimize ν via WAIC","category":"section"},{"location":"model_fitting/#Model-Comparison-(WAIC)","page":"Model Fitting","title":"Model Comparison (WAIC)","text":"When run_model_comparison = true, both Normal and robust regression models are fitted for all proteins and compared using the Widely Applicable Information Criterion (WAIC):\n\nWAIC = -2 × (lppd - p_waic)\n\nwhere:\n\nlppd = log pointwise predictive density (model fit)\np_waic = effective number of parameters (model complexity)\n\nLower WAIC indicates better predictive performance.\n\n# Results include:\n# - WAICResult for each model (waic, lppd, p_waic, se)\n# - ModelComparisonResult (delta_waic, preferred model)\n# - Per-protein WAIC when n_proteins is small enough","category":"section"},{"location":"model_fitting/#ν-Optimization","page":"Model Fitting","title":"ν Optimization","text":"When optimize_nu = true, BayesInteractomics searches for the optimal degrees-of-freedom:\n\nSearch range: ν ∈ [3, 50]\nMethod: Brent's method minimizing WAIC\nResult: Automatically sets student_t_nu to the optimal value\nDiagnostic: nu_optimization_plot shows WAIC vs. ν","category":"section"},{"location":"model_fitting/#Evidence-Combination","page":"Model Fitting","title":"Evidence Combination","text":"","category":"section"},{"location":"model_fitting/#Copula-Based-Combination-(default)","page":"Model Fitting","title":"Copula-Based Combination (default)","text":"Individual Bayes factors are combined using copulas:\n\nConvert BFs to posterior probabilities (assuming uniform prior)\nFit null copula from permuted data (H₀ distribution)\nFit mixture via EM: π₀ · f₀(p) + π₁ · f₁(p)\nCompute joint Bayes factor from likelihood ratio\n\nSupported copula families: | Family | Tail dependence | Symmetry | |–-|–-|–-| | Clayton | Lower tail | Asymmetric | | Frank | No tail | Symmetric | | Gumbel | Upper tail | Asymmetric | | Gaussian | No tail | Symmetric | | Joe | Upper tail | Asymmetric |\n\nBest copula is selected automatically via BIC (or AIC).\n\nEM algorithm features:\n\nMultiple random restarts (n_restarts = 20)\nSQUAREM acceleration for faster convergence\nWeighted H₁ re-fitting in M-step (h1_refitting = true)\nInformative Beta prior on π₁ (experiment-type specific)\nBurn-in period before H₁ updates","category":"section"},{"location":"model_fitting/#Latent-Class-Combination-(alternative)","page":"Model Fitting","title":"Latent Class Combination (alternative)","text":"combination_method = :latent_class\n\nUses variational message passing (VMP) to fit a 2-class mixture model. Does not require a pre-computed H₀ file, making it useful when permutation-based null distributions are unavailable.","category":"section"},{"location":"model_fitting/#Priors","page":"Model Fitting","title":"Priors","text":"","category":"section"},{"location":"model_fitting/#EM-Prior-on-π","page":"Model Fitting","title":"EM Prior on π₁","text":"The mixing proportion π₁ (fraction of true interactors) uses an informative Beta prior:\n\nPreset α β Expected π₁\n:APMS 20 180 ~10%\n:BioID 30 120 ~20%\n:TurboID 40 110 ~25%\n:default 25 175 ~12.5%\n:permissive 50 100 ~33%\n:stringent 10 190 ~5%\n:empirical_bayes — — Data-driven\n\nCustom priors: em_prior = (α = 15.0, β = 85.0)","category":"section"},{"location":"model_fitting/#HBM-Priors","page":"Model Fitting","title":"HBM Priors","text":"HBM priors are estimated empirically from the data:\n\nτ₀(): Fitted Gamma distribution on precision, estimated from control variability\nμ₀(): Returns (median_of_means, max_variance), estimated from overall abundance","category":"section"},{"location":"model_fitting/#Practical-Interpretation","page":"Model Fitting","title":"Practical Interpretation","text":"","category":"section"},{"location":"model_fitting/#Bayes-Factor-Scale","page":"Model Fitting","title":"Bayes Factor Scale","text":"Bayes Factor log₁₀(BF) Interpretation\n> 100 > 2 Decisive evidence\n30–100 1.5–2 Very strong\n10–30 1–1.5 Strong\n3–10 0.5–1 Moderate\n1–3 0–0.5 Weak\n< 1 < 0 Favors H₀\n\nCombined Bayes factors from multiple models are more reliable than any individual model, as they integrate complementary evidence sources.","category":"section"},{"location":"model_fitting/#API-Reference","page":"Model Fitting","title":"API Reference","text":"","category":"section"},{"location":"model_fitting/#BayesInteractomics.betabernoulli","page":"Model Fitting","title":"BayesInteractomics.betabernoulli","text":"betabernoulli(data::InteractionData, idx::I, n_control::I, n_sample::I; create_plot::Bool=false) where {I <: Int}\n\nPerforms a Bayesian A/B test on protein detection rates using a Beta-Bernoulli model.\n\nThis function compares the detection rate of a specific protein (idx) between a sample group and a control group. It models the detection of a protein as a Bernoulli trial (detected or not detected). The underlying detection rate parameter, θ, is given a conjugate Beta prior (hardcoded as Beta(3, 3)), which represents a weak belief that the true rate is centered around 0.5.\n\nThe function calculates the analytical posterior distributions for the detection rates in both the sample group (θ_sample) and the control group (θ_control). It then uses numerical integration to compute the posterior probability p = P(θ_sample > θ_control | data).\n\nFinally, it computes the Bayes Factor (BF₁₀) for the one-sided hypothesis:\n\nH₁: The detection rate in the sample is greater than in the control (θsample > θcontrol).\nH₀: The detection rate in the sample is not greater than in the control (θsample ≤ θcontrol).\n\nArguments\n\ndata::InteractionData: The main data structure containing protein interaction data.\nidx::Int: The index of the specific protein to be analyzed from the data structure.\nn_control::Int: The number of data points in the sample group's data array.\nn_sample::Int: The number of data points in the control group's data array.\ncreate_plot::Bool=false: Whether to create visualization plot (expensive, defaults to false).\n\nReturns\n\nA Tuple{Float64, Float64, Union{Plots.Plot, Nothing}} containing:\n\nBF::Float64: The Bayes Factor in favor of H₁. A value > 1 indicates evidence for the sample group having a higher detection rate.\np::Float64: The posterior probability that the sample detection rate is greater than the control rate.\nplt::Union{Plots.Plot, Nothing}: A plot object from StatsPlots.jl visualizing the prior and the two posterior distributions, or nothing if create_plot=false.\n\n\n\n\n\n","category":"function"},{"location":"model_fitting/#BayesInteractomics.BayesFactorHBM","page":"Model Fitting","title":"BayesInteractomics.BayesFactorHBM","text":"BayesFactorHBM(result::HBMResult; threshold::Float64 = 0.0)\n\nCompute the Bayes factor for each parameter's log₂ fold change between the posterior and prior from a hierarchical Bayesian model (HBM).\n\nArguments\n\nresult: An HBMResult object containing posterior and prior inference results.\nthreshold: The log₂FC threshold for hypothesis testing (default = 0.0).\n\nReturns\n\nTuple of (BF::Vector{Float64}, postProb::Vector{Float64}, priorProb::Vector{Float64}), representing Bayes factors, posterior probability and prior probability.\n\n\n\n\n\n","category":"function"},{"location":"model_fitting/#BayesInteractomics.BayesFactorRegression","page":"Model Fitting","title":"BayesInteractomics.BayesFactorRegression","text":"BayesFactorRegression(result::RegressionResultMultipleProtocols)\n\nComputes the Bayes factor for a given posterior and prior inference results. \n    H1: ρ > 0.0\n    H0: ρ <= 0.0\n\nArgs:\n    - posterior<:InferenceResult:   posterior inference result object of type InferenceResult \n    - prior<:InferenceResult:       prior inference result object of type InferenceResult\n\nReturns:\n    - Bayes factor\n    - posterior probability\n    - prior probability\n\n\n\n\n\n","category":"function"},{"location":"model_fitting/#BayesInteractomics.probability_of_direction","page":"Model Fitting","title":"BayesInteractomics.probability_of_direction","text":"probability_of_direction(draws::Vector{Float64})\nprobability_of_direction(draws::Vector{Vector{Float64}})\nprobability_of_direction(posterior::Union{MixtureModel,Normal{Float64}})\n\nCompute the probability of direction (Maximum Probability of Effect - MPE) for a posterior distribution.\n\nReturns\n\npd::Float64: Probability of direction (between 0.5 and 1.0).\ndirection::String: \"+\" if effect is more likely positive, \"-\" if negative, or \"~\" if undecidable.\n\n\n\n\n\n","category":"function"},{"location":"model_fitting/#BayesInteractomics.pd_to_p_value","page":"Model Fitting","title":"BayesInteractomics.pd_to_p_value","text":"pd_to_p_value(pd, two_sided::Bool)\nConverts the probability of direction (pd) to a p-value.\n\n# Arguments\n- `pd::Float64`: The probability of direction, assumed to be between 0.5 and 1.0.\n- `two_sided::Bool`: Whether to return a two-sided p-value (default = `true`).\n\n# Returns\n- `p_value::Float64`: The corresponding frequentist-style p-value.\n\n\n\n\n\n","category":"function"},{"location":"model_fitting/#BayesInteractomics.compute_waic","page":"Model Fitting","title":"BayesInteractomics.compute_waic","text":"compute_waic(data, regression_results, name_to_idx, refID; n_draws=1000, rng=GLOBAL_RNG) -> WAICResult\n\nCompute WAIC from VMP posteriors for the regression model.\n\nWAIC = -2 * (lppd - p_waic), where:\n\nlppd = Σᵢ log(1/S × Σₛ p(yᵢ | θˢ)) is the log pointwise predictive density\npwaic = Σᵢ vars(log p(yᵢ | θˢ)) is the effective number of parameters\n\nFor each observation yᵢ with reference xᵢ, draws S samples from q(α), q(β), q(τ) [and q(w) for robust model] and computes the pointwise log-likelihood.\n\nArguments\n\ndata::InteractionData: The interaction data\nregression_results::Dict{String, <:Union{RegressionResult, RobustRegressionResult}}: Per-protein regression results\nname_to_idx::Dict{String, Int}: Map from protein name to data index\nrefID::Int: Reference protein index\n\nKeywords\n\nn_draws::Int=1000: Number of posterior draws for WAIC estimation\nrng::AbstractRNG=GLOBAL_RNG: Random number generator\n\nReturns\n\nWAICResult: WAIC statistics\n\n\n\n\n\n","category":"function"},{"location":"model_fitting/#BayesInteractomics.compare_regression_models","page":"Model Fitting","title":"BayesInteractomics.compare_regression_models","text":"compare_regression_models(data, normal_results, robust_results, name_to_idx, refID; n_draws=1000, rng=GLOBAL_RNG) -> ModelComparisonResult\n\nCompare Normal vs. robust (Student-t) regression models via WAIC.\n\nArguments\n\ndata::InteractionData: The interaction data\nnormal_results::Dict{String, <:RegressionResult}: Results from Normal regression\nrobust_results::Dict{String, <:RobustRegressionResult}: Results from robust regression\nname_to_idx::Dict{String, Int}: Map from protein name to data index\nrefID::Int: Reference protein index\n\nKeywords\n\nn_draws::Int=1000: Number of posterior draws for WAIC estimation\nrng::AbstractRNG=GLOBAL_RNG: Random number generator\n\nReturns\n\nModelComparisonResult: WAIC comparison with preferred model indication\n\n\n\n\n\n","category":"function"},{"location":"model_fitting/#BayesInteractomics.optimize_nu","page":"Model Fitting","title":"BayesInteractomics.optimize_nu","text":"optimize_nu(data::InteractionData, config; lower=3.0, upper=50.0) -> NuOptimizationResult\n\nOptimize the Student-t degrees-of-freedom parameter ν over [lower, upper] using Brent's method, minimizing WAIC for the robust regression model.\n\nThe Normal regression WAIC is computed once as a baseline for comparison.\n\nArguments\n\ndata::InteractionData: The interaction data\nconfig: Configuration object with fields refID::Int and verbose::Bool (e.g., CONFIG)\n\nKeywords\n\nlower::Float64=3.0: Lower bound for ν search\nupper::Float64=50.0: Upper bound for ν search\n\nReturns\n\nNuOptimizationResult: Optimization results including optimal ν, WAIC trace, and comparison\n\n\n\n\n\n","category":"function"},{"location":"model_fitting/#BayesInteractomics.combined_BF","page":"Model Fitting","title":"BayesInteractomics.combined_BF","text":"combined_BF(bf::BayesFactorTriplet, refID::Int64; kwargs...)\n\nCombine individual Bayes factors using copula-based mixture model.\n\nArguments\n\nbf::BayesFactorTriplet: Bayes factors from the three models\nrefID::Int64: Index of the reference (bait) protein\n\nKeywords\n\nH0_file::String=\"copula_H0.xlsx\": Path to precomputed H0 Bayes factors\nmax_iter::Int=1000: Maximum EM iterations\ninit_π0::Float64=0.80: Initial π₀ (null proportion)\nprior::Union{Symbol, NamedTuple}=:default: Prior for π₁ (:APMS, :BioID, :TurboID, :default, :permissive, :stringent, :empirical_bayes, or custom (α=, β=))\nn_restarts::Int=20: Number of EM restarts (set to 1 to disable)\ncopula_criterion::Symbol=:BIC: Copula selection criterion (:BIC, :AIC, :loglik)\nh1_refitting::Bool=true: Enable weighted H1 updates in M-step\nburn_in::Int=10: Number of iterations before starting H1 re-fitting\nuse_acceleration::Bool=true: Enable SQUAREM acceleration for faster convergence\nverbose::Bool=true: Print progress information\n\nReturns\n\nCombinedBayesResult: Combined Bayes factors and posterior probabilities\n\n\n\n\n\n","category":"function"},{"location":"model_fitting/#BayesInteractomics.fit_copula","page":"Model Fitting","title":"BayesInteractomics.fit_copula","text":"fit_copula(p::EvidenceTriplet; searchBestCopula=true, copula=FrankCopula, criterion=:BIC)\n\nFit a copula to the posterior probability triplet.\n\nArguments\n\np::EvidenceTriplet: Evidence triplet (Bayes factors or posterior probabilities)\n\nKeywords\n\nsearchBestCopula::Bool=true: If true, select best copula family automatically\ncopula=FrankCopula: Copula type to use if searchBestCopula=false\ncriterion::Symbol=:BIC: Selection criterion when searching (:BIC, :AIC, :loglik)\n\nReturns\n\nFitted copula object\n\n\n\n\n\n","category":"function"},{"location":"model_fitting/#BayesInteractomics.compare_copulas","page":"Model Fitting","title":"BayesInteractomics.compare_copulas","text":"compare_copulas(p::EvidenceTriplet; criterion::Symbol=:BIC)\n\nFits multiple copulas to posterior probabilities and compares their fit using the specified criterion. Returns a sorted DataFrame.\n\nIf p is a BayesFactorTriplet, it is converted to posterior probabilities (assuming prior odds = 1).\n\nArguments\n\np::EvidenceTriplet: Vector of posterior probabilities or Bayes Factors\n\nKeywords\n\ncriterion::Symbol=:BIC: Selection criterion (:BIC, :AIC, or :loglik)\n\nReturns\n\nDataFrame: Sorted comparison with columns Family, LogLik, BIC, AIC\n\n\n\n\n\n","category":"function"},{"location":"model_fitting/#BayesInteractomics.posterior_probability_from_bayes_factor","page":"Model Fitting","title":"BayesInteractomics.posterior_probability_from_bayes_factor","text":"posterior_probability_from_bayes_factor(bf::BayesFactorTriplet) -> PosteriorProbabilityTriplet\n\nConverts a BayesFactorTriplet into a PosteriorProbabilityTriplet.\n\nThis function takes a triplet of Bayes factor vectors (for enrichment, correlation, and detection) and converts each vector into posterior probabilities, assuming prior odds of 1. It then returns these new vectors wrapped in a PosteriorProbabilityTriplet struct.\n\nArguments\n\nbf::BayesFactorTriplet{R}: A struct containing vectors of Bayes factors for enrichment, correlation, and detection.\n\nReturns\n\nPosteriorProbabilityTriplet: A struct containing the corresponding posterior probability vectors.\n\n\n\n\n\nposterior_probability_from_bayes_factor(bf)\n\nConverts a Bayes Factor to a posterior probability assuming prior odds = 1. \n\nEdge cases:\n- If bf = Inf, returns 1.0\n- If bf = -Inf, returns 0.0\n- If bf = NaN, returns 0.5 (uninformative)\n\n\n\n\n\n","category":"function"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"This page showcases real-world analysis workflows using BayesInteractomics. All example scripts are available in the examples/ directory of the package repository.","category":"section"},{"location":"examples/#Example-1:-HAP40-Interactome-Analysis","page":"Examples","title":"Example 1: HAP40 Interactome Analysis","text":"This example demonstrates analyzing the interactome of HAP40 (Huntingtin-associated protein 40) using data from multiple experimental protocols.","category":"section"},{"location":"examples/#Scientific-Context","page":"Examples","title":"Scientific Context","text":"HAP40 is a protein that associates with Huntingtin (HTT) and plays important roles in neurodegenerative diseases. This analysis identifies HAP40-interacting proteins by combining evidence from two different affinity purification approaches:\n\nGST-tagged HAP40 pulldown\nStrep-tagged HAP40 pulldown","category":"section"},{"location":"examples/#Data-Structure","page":"Examples","title":"Data Structure","text":"The experiment includes:\n\nTwo protocols: GST-HAP40 and HAP40-Strep\nThree experiments per protocol: Representing different biological conditions or replicates\nMultiple replicates: 3 control and 3 sample replicates per experiment","category":"section"},{"location":"examples/#Complete-Workflow","page":"Examples","title":"Complete Workflow","text":"using BayesInteractomics\n\n# Define base directory for results\nbasepath = \"path/to/HAP40_analysis\"\n\n# Configure analysis with two protocols\nconfig = CONFIG(\n    # Input files - one per protocol\n    datafile = [\n        \"data/GST_HAP40.xlsx\",\n        \"data/HAP40_Strep.xlsx\"\n    ],\n\n    # Control sample column mappings\n    # Protocol 1 (GST-HAP40): 3 experiments with 3 replicates each\n    # Protocol 2 (HAP40-Strep): 3 experiments with varying replicates\n    control_cols = [\n        Dict(1 => [2,3,4], 2 => [5,6,7], 3 => [8,9,10]),    # Protocol 1: 9 controls\n        Dict(1 => [2,3,4], 2 => [5], 3 => [6,7])            # Protocol 2: 6 controls\n    ],\n\n    # Sample column mappings\n    sample_cols = [\n        Dict(1 => [11,12,13], 2 => [14,15,16], 3 => [17,18,19]), # Protocol 1: 9 samples\n        Dict(1 => [8,9,10], 2 => [11,12,13], 3 => [14,15])       # Protocol 2: 8 samples\n    ],\n\n    # Bait protein specification\n    poi = \"9606.ENSP00000479624\",  # UniProt ID for HAP40\n    refID = 1,                      # HAP40 is in first row of data\n\n    # Total sample counts\n    n_controls = 15,  # 9 + 6\n    n_samples = 17,   # 9 + 8\n\n    # Normalization - IMPORTANT for multiple protocols\n    normalise_protocols = true,\n\n    # Output files\n    H0_file = joinpath(basepath, \"copula_H0.xlsx\"),\n    results_file = joinpath(basepath, \"final_results.xlsx\"),\n    volcano_file = joinpath(basepath, \"volcano_plot.svg\"),\n    convergence_file = joinpath(basepath, \"convergence.svg\"),\n    evidence_file = joinpath(basepath, \"evidence.svg\"),\n\n    # Visualization options\n    vc_legend_pos = :topleft,\n    plotHBMdists = false,   # Set true to plot individual protein distributions\n    plotlog2fc = false,\n    plotregr = false,\n    verbose = true\n)\n\n# Run complete analysis\nresults = run_analysis(config)\n\n# Examine top interactions\ntop_interactions = first(\n    sort(results, :Posterior_Probability, rev=true),\n    20\n)\n\nprintln(\"Top 20 HAP40 interactors:\")\nprintln(top_interactions[:, [:Protein, :Posterior_Probability, :log2FC_mean,\n                              :BF_enrichment, :BF_correlation, :BF_detection]])\n\n# Filter for high-confidence hits\nhigh_confidence = filter(\n    row -> row.Posterior_Probability > 0.95 && row.log2FC_mean > 1.0,\n    results\n)\n\nprintln(\"\\nHigh-confidence interactions (P > 0.95, log2FC > 1): $(nrow(high_confidence))\")","category":"section"},{"location":"examples/#Analyzing-Individual-Protocols","page":"Examples","title":"Analyzing Individual Protocols","text":"You can also analyze each protocol separately to understand protocol-specific effects:\n\n# GST-HAP40 only\ngst_config = CONFIG(\n    datafile = [\"data/GST_HAP40.xlsx\"],\n    control_cols = [Dict(1 => [2,3,4], 2 => [5,6,7], 3 => [8,9,10])],\n    sample_cols = [Dict(1 => [11,12,13], 2 => [14,15,16], 3 => [17,18,19])],\n    poi = \"9606.ENSP00000479624\",\n    refID = 1,\n    n_controls = 9,\n    n_samples = 9,\n    normalise_protocols = false,  # Single protocol\n    H0_file = joinpath(basepath, \"GST_HAP40/copula_H0.xlsx\"),\n    results_file = joinpath(basepath, \"GST_HAP40/results.xlsx\"),\n    volcano_file = joinpath(basepath, \"GST_HAP40/volcano.svg\")\n)\n\ngst_results = run_analysis(gst_config)\n\n# HAP40-Strep only\nstrep_config = CONFIG(\n    datafile = [\"data/HAP40_Strep.xlsx\"],\n    control_cols = [Dict(1 => [2,3,4], 2 => [5], 3 => [6,7])],\n    sample_cols = [Dict(1 => [8,9,10], 2 => [11,12,13], 3 => [14,15])],\n    poi = \"9606.ENSP00000479624\",\n    refID = 1,\n    n_controls = 6,\n    n_samples = 8,\n    normalise_protocols = false,\n    H0_file = joinpath(basepath, \"HAP40_Strep/copula_H0.xlsx\"),\n    results_file = joinpath(basepath, \"HAP40_Strep/results.xlsx\"),\n    volcano_file = joinpath(basepath, \"HAP40_Strep/volcano.svg\")\n)\n\nstrep_results = run_analysis(strep_config)\n\n# Compare results across protocols\nusing DataFrames, StatsBase\n\n# Merge results\nmerged = innerjoin(\n    gst_results[:, [:Protein, :Posterior_Probability => :PP_GST]],\n    strep_results[:, [:Protein, :Posterior_Probability => :PP_Strep]],\n    on = :Protein\n)\n\n# Calculate correlation\ncor_pp = cor(merged.PP_GST, merged.PP_Strep)\nprintln(\"Correlation between protocol posterior probabilities: $(round(cor_pp, digits=3))\")\n\n# Identify protocol-consistent hits\nconsistent_hits = filter(\n    row -> row.PP_GST > 0.9 && row.PP_Strep > 0.9,\n    merged\n)\nprintln(\"Proteins with high confidence in both protocols: $(nrow(consistent_hits))\")","category":"section"},{"location":"examples/#Example-2:-Meta-Analysis-with-Multiple-Imputation","page":"Examples","title":"Example 2: Meta-Analysis with Multiple Imputation","text":"This advanced example demonstrates combining data from multiple experiments with substantial missing data using multiple imputation.","category":"section"},{"location":"examples/#Scientific-Context-2","page":"Examples","title":"Scientific Context","text":"This analysis examines the interactome of Huntingtin (HTT), the protein implicated in Huntington's disease. Data come from 6 different published studies, each using different AP-MS protocols. The combined dataset has substantial missing data (~40%), requiring multiple imputation for robust inference.","category":"section"},{"location":"examples/#Workflow-Overview","page":"Examples","title":"Workflow Overview","text":"Impute missing data using an appropriate method (e.g., MissForest, KNN)\nCreate M imputed datasets (typically M=5)\nRun BayesInteractomics on each imputed dataset\nPool results following Rubin's rules","category":"section"},{"location":"examples/#Data-Preparation","page":"Examples","title":"Data Preparation","text":"using BayesInteractomics\n\nconst BASEPATH = \"path/to/HTT_meta_analysis\"\n\n# Helper function to count total samples across experiments\nfunction count_samples(column_dicts, n_dummy)\n    total = 0\n    for dict in column_dicts\n        n = sum(length(cols) for (_, cols) in dict)\n        total += n\n    end\n    return total - n_dummy\nend\n\n# Define column mappings for 6 protocols (studies)\n# Note: Dummy columns (162-165) are used for padding where experiments are missing\n\n# Sample columns for each protocol\ns_grecco    = Dict(1 => [2,3,4,162], 2 => [5,6,7,162], 3 => [162,163,164,165], 4 => [162,163,164,165])\ns_gutierrez = Dict(1 => [29,30,31,162], 2 => [162,163,164,165], 3 => [162,163,164,165], 4 => [162,163,164,165])\ns_sap       = Dict(1 => [36,37,38,39], 2 => [162,163,164,165], 3 => [162,163,164,165], 4 => [162,163,164,165])\ns_grecco_2  = Dict(1 => [48,49,50,51], 2 => [52,53,54,55], 3 => [60,61,62,63], 4 => [64,65,66,162])\ns_grecco_3  = Dict(1 => [92,93,94,162], 2 => [95,96,97,162], 3 => [100,101,102,162], 4 => [103,104,105,162])\ns_grecco_4  = Dict(1 => [128,129,130,162], 2 => [131,132,133,162], 3 => [137,138,139,162], 4 => [140,141,142,162])\n\n# Control columns for each protocol\nc_grecco    = Dict(1 => [14,15,16,162], 2 => [17,18,19,162], 3 => [162,163,164,165], 4 => [162,163,164,165])\nc_gutierrez = Dict(1 => [26,27,28,162], 2 => [162,163,164,165], 3 => [162,163,164,165], 4 => [162,163,164,165])\nc_sap       = Dict(1 => [32,33,34,35], 2 => [162,163,164,165], 3 => [162,163,164,165], 4 => [162,163,164,165])\nc_grecco_2  = Dict(1 => [44,45,46,47], 2 => [44,45,46,47], 3 => [56,57,58,59], 4 => [56,57,58,59])\nc_grecco_3  = Dict(1 => [90, 91, 162, 163], 2 => [90, 91, 162, 163], 3 => [98,99,162,163], 4 => [98,99,162,163])\nc_grecco_4  = Dict(1 => [125,126,127,162], 2 => [125,126,127,162], 3 => [134,135,136,162], 4 => [134,135,136,162])\n\nsample_cols = [s_grecco, s_gutierrez, s_sap, s_grecco_2, s_grecco_3, s_grecco_4]\ncontrol_cols = [c_grecco, c_gutierrez, c_sap, c_grecco_2, c_grecco_3, c_grecco_4]\n\n# Number of dummy columns used for padding\nn_dummy_samples = 44\nn_dummy_controls = 47","category":"section"},{"location":"examples/#Loading-Imputed-Datasets","page":"Examples","title":"Loading Imputed Datasets","text":"# Load M=5 imputed datasets\nimputed_data = InteractionData[]\n\nfor i in 1:5\n    # Each imputation uses the same column mappings\n    files = [\n        joinpath(BASEPATH, \"imputed_data/dataset_imp_$i.xlsx\"),\n        joinpath(BASEPATH, \"imputed_data/dataset_imp_$i.xlsx\"),\n        joinpath(BASEPATH, \"imputed_data/dataset_imp_$i.xlsx\"),\n        joinpath(BASEPATH, \"imputed_data/dataset_imp_$i.xlsx\"),\n        joinpath(BASEPATH, \"imputed_data/dataset_imp_$i.xlsx\"),\n        joinpath(BASEPATH, \"imputed_data/dataset_imp_$i.xlsx\")\n    ]\n\n    data = load_data(\n        files,\n        sample_cols,\n        control_cols,\n        normalise_protocols = true\n    )\n\n    push!(imputed_data, data)\n    @info \"Loaded imputed dataset $i\"\nend\n\n# Also load raw data for Beta-Bernoulli model (uses detection, not intensity)\nraw_data = load_data(\n    [joinpath(BASEPATH, \"dataset.xlsx\") for _ in 1:6],\n    sample_cols,\n    control_cols,\n    normalise_protocols = true\n)","category":"section"},{"location":"examples/#Running-Analysis-on-Imputed-Data","page":"Examples","title":"Running Analysis on Imputed Data","text":"# Define analysis configuration\nanalysis_config = CONFIG(\n    sample_cols = sample_cols,\n    control_cols = control_cols,\n    n_controls = count_samples(control_cols, n_dummy_controls),\n    n_samples = count_samples(sample_cols, n_dummy_samples),\n    refID = 237,  # Row index of HTT in dataset\n    poi = \"ENSP00000347184\",  # UniProt ID for HTT\n\n    # File paths\n    datafile = [joinpath(BASEPATH, \"dataset.xlsx\") for _ in 1:6],\n    H0_file = joinpath(BASEPATH, \"wtHTT/copula_H0.xlsx\"),\n    results_file = joinpath(BASEPATH, \"wtHTT/results.xlsx\"),\n    volcano_file = joinpath(BASEPATH, \"wtHTT/volcano_plot.svg\"),\n    convergence_file = joinpath(BASEPATH, \"wtHTT/convergence.svg\"),\n    evidence_file = joinpath(BASEPATH, \"wtHTT/evidence.svg\"),\n\n    # Analysis parameters\n    normalise_protocols = true,\n    verbose = true\n)\n\n# Run analysis with multiple imputation\n# This will:\n# 1. Run Beta-Bernoulli on raw_data (detection model doesn't use imputed values)\n# 2. Run HBM and Regression on each imputed dataset\n# 3. Pool Bayes factors across imputations\nresults = run_analysis(analysis_config, imputed_data, raw_data)\n\n# Results now incorporate uncertainty from both:\n# - Statistical inference (Bayesian posterior)\n# - Missing data (imputation variance)\n\nprintln(\"Analysis complete. Found $(nrow(filter(r -> r.Posterior_Probability > 0.95, results))) high-confidence interactions.\")","category":"section"},{"location":"examples/#Comparing-Wild-type-vs-Mutant-HTT","page":"Examples","title":"Comparing Wild-type vs Mutant HTT","text":"The meta-analysis example also includes comparing interactomes of wild-type versus mutant HTT:\n\n# Configure comparison by swapping sample/control assignments\n# Wild-type HTT as control, Mutant HTT as sample\ncomparison_config = CONFIG(\n    sample_cols = [...],      # Mutant HTT columns\n    control_cols = [...],     # Wild-type HTT columns\n    # ... other parameters same as above\n)\n\ncomparison_results = run_analysis(comparison_config, imputed_data, raw_data)\n\n# Identify differential interactors\n# High probability in mutant, low in wild-type\ndifferential = filter(\n    row -> row.Posterior_Probability > 0.9 && row.log2FC_mean > 2.0,\n    comparison_results\n)\n\nprintln(\"Proteins preferentially enriched with mutant HTT: $(nrow(differential))\")","category":"section"},{"location":"examples/#Example-3:-Custom-Visualization","page":"Examples","title":"Example 3: Custom Visualization","text":"BayesInteractomics provides flexible plotting functions. Here are examples of customizing visualizations:","category":"section"},{"location":"examples/#Volcano-Plot-Customization","page":"Examples","title":"Volcano Plot Customization","text":"using BayesInteractomics, StatsPlots\n\n# After running analysis\nresults = run_analysis(config)\n\n# Extract data for plotting\nlog2fc = results.log2FC_mean\nneg_log_p = -log10.(1 .- results.Posterior_Probability)\nposterior_prob = results.Posterior_Probability\n\n# Create custom volcano plot\nvolcano = scatter(\n    log2fc,\n    neg_log_p,\n    xlabel = \"Log2 Fold Change\",\n    ylabel = \"-Log10(1 - Posterior Probability)\",\n    title = \"HAP40 Interactome Volcano Plot\",\n    marker_z = posterior_prob,\n    color = :viridis,\n    colorbar_title = \"Posterior Probability\",\n    markersize = 3,\n    alpha = 0.7,\n    legend = false\n)\n\n# Add threshold lines\nhline!([2], linestyle=:dash, color=:red, label=\"P > 0.99\")\nvline!([-1, 1], linestyle=:dash, color=:blue, label=\"2-fold change\")\n\n# Annotate top hits\ntop_n = 10\ntop_proteins = first(sort(results, :Posterior_Probability, rev=true), top_n)\nfor row in eachrow(top_proteins)\n    annotate!(row.log2FC_mean, -log10(1 - row.Posterior_Probability),\n              text(row.Protein, 6, :left))\nend\n\nsavefig(volcano, \"custom_volcano_plot.svg\")","category":"section"},{"location":"examples/#Evidence-Distribution-Plots","page":"Examples","title":"Evidence Distribution Plots","text":"# Plot distribution of individual Bayes factors\nusing StatsPlots\n\np1 = histogram(\n    log10.(results.BF_enrichment),\n    xlabel = \"Log10(BF Enrichment)\",\n    ylabel = \"Count\",\n    title = \"Enrichment Evidence\",\n    bins = 50,\n    alpha = 0.7,\n    color = :blue\n)\n\np2 = histogram(\n    log10.(results.BF_correlation),\n    xlabel = \"Log10(BF Correlation)\",\n    ylabel = \"Count\",\n    title = \"Correlation Evidence\",\n    bins = 50,\n    alpha = 0.7,\n    color = :green\n)\n\np3 = histogram(\n    log10.(results.BF_detection),\n    xlabel = \"Log10(BF Detection)\",\n    ylabel = \"Count\",\n    title = \"Detection Evidence\",\n    bins = 50,\n    alpha = 0.7,\n    color = :red\n)\n\nevidence_plot = plot(p1, p2, p3, layout=(1,3), size=(1200, 400))\nsavefig(evidence_plot, \"evidence_distributions.svg\")","category":"section"},{"location":"examples/#Comparing-Results-Across-Conditions","page":"Examples","title":"Comparing Results Across Conditions","text":"# Compare interactomes between two conditions\nusing DataFrames, StatsPlots\n\n# Load results from two conditions\nwt_results = run_analysis(wt_config)\nmut_results = run_analysis(mut_config)\n\n# Merge on protein ID\ncomparison = innerjoin(\n    wt_results[:, [:Protein, :Posterior_Probability => :PP_WT, :log2FC_mean => :FC_WT]],\n    mut_results[:, [:Protein, :Posterior_Probability => :PP_MUT, :log2FC_mean => :FC_MUT]],\n    on = :Protein\n)\n\n# Scatter plot comparing posterior probabilities\nscatter(\n    comparison.PP_WT,\n    comparison.PP_MUT,\n    xlabel = \"Posterior Probability (WT)\",\n    ylabel = \"Posterior Probability (Mutant)\",\n    title = \"Interactome Comparison: WT vs Mutant\",\n    markersize = 3,\n    alpha = 0.6,\n    color = :steelblue,\n    legend = false\n)\n\n# Add diagonal line\nplot!([0, 1], [0, 1], linestyle=:dash, color=:red, label=\"Equal\")\n\n# Annotate differentially enriched\ndifferential = filter(row -> abs(row.PP_WT - row.PP_MUT) > 0.5, comparison)\nfor row in eachrow(differential)\n    annotate!(row.PP_WT, row.PP_MUT, text(row.Protein, 5, :left))\nend\n\nsavefig(\"wt_vs_mutant_comparison.svg\")","category":"section"},{"location":"examples/#Tips-for-Real-Analyses","page":"Examples","title":"Tips for Real Analyses","text":"","category":"section"},{"location":"examples/#Data-Quality-Checks","page":"Examples","title":"Data Quality Checks","text":"Before running the full analysis, perform quality checks:\n\n# Load data\ndata = load_data(files, sample_cols, control_cols)\n\n# Check data dimensions\nprintln(\"Number of proteins: $(getNoProteins(data))\")\nprintln(\"Number of protocols: $(getNoProtocols(data))\")\n\n# Check missing data percentage\nfunction missing_percentage(data::InteractionData)\n    total_cells = 0\n    missing_cells = 0\n\n    for protocol in data\n        for (exp_id, exp_data) in protocol.experiments\n            total_cells += length(exp_data)\n            missing_cells += sum(ismissing.(exp_data))\n        end\n    end\n\n    return 100 * missing_cells / total_cells\nend\n\nprintln(\"Missing data: $(round(missing_percentage(data), digits=1))%\")","category":"section"},{"location":"examples/#Batch-Processing-Multiple-Baits","page":"Examples","title":"Batch Processing Multiple Baits","text":"For analyzing multiple bait proteins in one dataset:\n\n# List of bait proteins\nbaits = [\n    (name=\"HAP40\", id=\"ENSP00000479624\", refID=1),\n    (name=\"HTT\", id=\"ENSP00000347184\", refID=237),\n    (name=\"PROTEIN_X\", id=\"ENSP00000123456\", refID=500)\n]\n\n# Analyze each bait\nall_results = Dict()\n\nfor bait in baits\n    println(\"Analyzing $(bait.name)...\")\n\n    config = CONFIG(\n        # ... common parameters ...\n        poi = bait.id,\n        refID = bait.refID,\n        results_file = \"results_$(bait.name).xlsx\"\n    )\n\n    results = run_analysis(config)\n    all_results[bait.name] = results\n\n    println(\"  Found $(nrow(filter(r -> r.Posterior_Probability > 0.95, results))) interactions\")\nend","category":"section"},{"location":"#BayesInteractomics.jl-Documentation","page":"Home","title":"BayesInteractomics.jl Documentation","text":"Welcome to the documentation for BayesInteractomics.jl, a comprehensive Julia package for Bayesian analysis of protein-protein interactions from mass spectrometry experiments.","category":"section"},{"location":"#What-is-BayesInteractomics?","page":"Home","title":"What is BayesInteractomics?","text":"BayesInteractomics provides a rigorous statistical framework for identifying genuine protein-protein interactions from Affinity-Purification Mass Spectrometry (AP-MS) and proximity labeling data. Unlike traditional approaches that rely on single statistical tests or ad-hoc filtering, BayesInteractomics integrates three complementary lines of evidence through principled Bayesian inference:\n\nDetection Evidence: Is the protein consistently detected across sample replicates versus controls? (Beta-Bernoulli model)\nEnrichment Evidence: Is the protein quantitatively enriched in samples? (Hierarchical Bayesian Model)\nCorrelation Evidence: Does the protein's abundance correlate with bait protein levels? (Bayesian Regression)\n\nThese individual Bayes factors are combined using copula-based mixture models to produce joint posterior probabilities that account for complex dependencies between evidence types.","category":"section"},{"location":"#Why-BayesInteractomics?","page":"Home","title":"Why BayesInteractomics?","text":"","category":"section"},{"location":"#Challenges-in-Interactome-Analysis","page":"Home","title":"Challenges in Interactome Analysis","text":"Protein interaction studies face several statistical challenges:\n\nNon-specific binding: Many detected proteins are contaminants rather than genuine interactors\nMissing data: Not all proteins are detected in every replicate\nProtocol heterogeneity: Different experimental methods yield different background distributions\nSmall sample sizes: Limited replicates make traditional frequentist methods unreliable\nMultiple testing: Thousands of proteins require careful control of false discovery rates","category":"section"},{"location":"#The-BayesInteractomics-Solution","page":"Home","title":"The BayesInteractomics Solution","text":"BayesInteractomics addresses these challenges through:\n\nHierarchical modeling: Shares information across protocols while accounting for protocol-specific variability\nPrincipled uncertainty quantification: Full posterior distributions rather than p-values\nMultiple evidence integration: Copulas flexibly model dependencies between different evidence types\nMissing data handling: Natural treatment of missing observations within Bayesian framework\nScalable inference: Efficient variational Bayes enables analysis of thousands of proteins","category":"section"},{"location":"#Package-Architecture","page":"Home","title":"Package Architecture","text":"","category":"section"},{"location":"#Hierarchical-Data-Structure","page":"Home","title":"Hierarchical Data Structure","text":"BayesInteractomics organizes data in a natural hierarchy that mirrors experimental design:\n\nInteractionData\n├── Protocol 1 (e.g., AP-MS)\n│   ├── Experiment 1 (biological replicate set 1)\n│   │   ├── Control samples\n│   │   └── Bait samples\n│   └── Experiment 2 (biological replicate set 2)\n│       ├── Control samples\n│       └── Bait samples\n└── Protocol 2 (e.g., proximity labeling)\n    └── Experiment 1\n        ├── Control samples\n        └── Bait samples\n\nThis structure enables:\n\nProtocol-level parameters (e.g., baseline detection rates)\nExperiment-level parameters (e.g., batch effects)\nSample-level observations with missing data","category":"section"},{"location":"#Analysis-Workflow","page":"Home","title":"Analysis Workflow","text":"The typical analysis workflow consists of:\n\nData Loading: Import from Excel/CSV files with flexible column specifications\nH0 Computation: Fit null hypothesis copula from negative control proteins\nParallel Analysis: Compute Bayes factors for all proteins across three models\nEM Fitting: Fit mixture copula to combine evidence (H0 vs. H1)\nResults Generation: Produce ranked interaction lists with posterior probabilities\nVisualization: Generate volcano plots, convergence diagnostics, and evidence distributions\n\nAll steps are orchestrated through the run_analysis() function with configuration via the CONFIG struct.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"BayesInteractomics requires Julia 1.9 or later.","category":"section"},{"location":"#From-Package-Registry","page":"Home","title":"From Package Registry","text":"using Pkg\nPkg.add(\"BayesInteractomics\")","category":"section"},{"location":"#Development-Version","page":"Home","title":"Development Version","text":"using Pkg\nPkg.add(url=\"https://github.com/ma-seefelder/BayesInteractomics.jl\")","category":"section"},{"location":"#First-Steps","page":"Home","title":"First Steps","text":"After installation, load the package and verify it works:\n\nusing BayesInteractomics\n\n# Check that key functions are available\n?CONFIG\n?load_data\n?run_analysis","category":"section"},{"location":"#Quick-Start-Example","page":"Home","title":"Quick Start Example","text":"Here's a minimal working example:\n\nusing BayesInteractomics\n\n# Configure analysis\nconfig = CONFIG(\n    datafile = [\"data/experiment.xlsx\"],\n    control_cols = [Dict(1 => [2,3,4])],\n    sample_cols = [Dict(1 => [5,6,7])],\n    poi = \"BAIT_PROTEIN_ID\",\n    refID = 1,\n    n_controls = 3,\n    n_samples = 3,\n    normalise_protocols = false,\n    H0_file = \"copula_H0.xlsx\",\n    results_file = \"results.xlsx\"\n)\n\n# Run complete pipeline\nresults = run_analysis(config)\n\n# View top interactions\nfirst(sort(results, :Posterior_Probability, rev=true), 10)","category":"section"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"Multiple Protocol Support: Integrate evidence from different experimental methods (AP-MS, BioID, APEX, etc.)\nHierarchical Bayesian Models: Share information across experiments while modeling heterogeneity\nCopula-Based Combination: Flexible dependency modeling for evidence integration\nRobust Regression: Student-t likelihood with WAIC-based model comparison\nMultiple Imputation: Proper uncertainty propagation for missing data\nParallel Computing: Multi-threaded analysis for efficient large-scale studies\nData Curation: Automated contaminant removal, protein group splitting, and synonym resolution via STRING\nDiagnostics: Posterior predictive checks, residual analysis, calibration assessment, and prior sensitivity analysis\nDifferential Analysis: Compare interactomes between conditions with classification of gained, lost, and unchanged interactions\nRich Visualizations: Volcano plots, convergence diagnostics, evidence distributions, and diagnostic plots\nInteractive Reports: Self-contained HTML reports with sortable tables and embedded plots\nNetwork Analysis: Graph construction, topology metrics, centrality analysis, community detection, and export to Cytoscape/Gephi\nMeta-Learning: Transfer knowledge across experiments via trained models","category":"section"},{"location":"#Documentation-Navigation","page":"Home","title":"Documentation Navigation","text":"This documentation is organized into several sections:","category":"section"},{"location":"#[Tutorial](tutorial.md)","page":"Home","title":"Tutorial","text":"Start here if you're new to BayesInteractomics. Step-by-step guide covering installation, data preparation, running your first analysis, and interpreting results.","category":"section"},{"location":"#User-Guide","page":"Home","title":"User Guide","text":"In-depth explanations of each component:\n\nData Loading: File formats, column specifications, and data structure\nData Curation: Contaminant removal, protein group splitting, synonym resolution, and duplicate merging\nAnalysis Pipeline: Complete workflow, configuration, caching, and parallelization\nModel Fitting: Statistical models, priors, robust regression, and model comparison\nModel Evaluation: Bayes factors, posterior probabilities, and quality metrics\nDiagnostics: Posterior predictive checks, residual analysis, calibration, and prior sensitivity\nDifferential Analysis: Comparing interactomes between conditions (gained, lost, unchanged)\nVisualization: Pipeline plots, per-protein plots, and diagnostic visualizations\nReports: Interactive HTML report generation\nNetwork Analysis: Network construction, topology analysis, hub identification, community detection, and export","category":"section"},{"location":"#[Examples](examples.md)","page":"Home","title":"Examples","text":"Real-world analysis workflows including:\n\nHAP40 interactome analysis with multiple protocols\nMeta-analysis combining evidence across experiments\nMultiple imputation workflow\nCustom visualization examples","category":"section"},{"location":"#[Mathematical-Background](mathematical_background.md)","page":"Home","title":"Mathematical Background","text":"Detailed mathematical exposition of:\n\nBeta-Bernoulli model for detection probability\nHierarchical Bayesian Model for enrichment\nBayesian linear regression for dose-response\nCopula theory and EM algorithm\nStatistical references and derivations","category":"section"},{"location":"#API-Reference","page":"Home","title":"API Reference","text":"Complete documentation of all exported functions and types. Functions are organized by module for easy navigation.","category":"section"},{"location":"#Getting-Help","page":"Home","title":"Getting Help","text":"If you encounter issues or have questions:\n\nCheck the Tutorial: Many common questions are answered in the step-by-step guide\nBrowse Examples: Real workflows may demonstrate what you need\nSearch the Docs: Use the search bar to find relevant sections\nGitHub Issues: Report bugs or request features at github.com/ma-seefelder/BayesInteractomics.jl","category":"section"},{"location":"#Citation","page":"Home","title":"Citation","text":"If you use BayesInteractomics in your research, please cite:\n\n@software{bayesinteractomics2025,\n  author = {Seefelder, Manuel},\n  title = {BayesInteractomics.jl: Bayesian Analysis of Protein Interactome Data},\n  year = {2025},\n  url = {https://github.com/ma-seefelder/BayesInteractomics.jl}\n}","category":"section"},{"location":"#License","page":"Home","title":"License","text":"BayesInteractomics.jl is released under the MIT License.","category":"section"},{"location":"tutorial/#Tutorial:-Getting-Started-with-BayesInteractomics","page":"Tutorial","title":"Tutorial: Getting Started with BayesInteractomics","text":"This tutorial will walk you through your first protein interactome analysis using BayesInteractomics. By the end, you'll understand how to prepare your data, run the analysis pipeline, and interpret the results.","category":"section"},{"location":"tutorial/#Prerequisites","page":"Tutorial","title":"Prerequisites","text":"Julia 1.9 or later installed\nBasic familiarity with the Julia REPL\nMass spectrometry data (AP-MS or proximity labeling)\nUnderstanding of your experimental design (controls vs. samples, replicates)","category":"section"},{"location":"tutorial/#Installation","page":"Tutorial","title":"Installation","text":"","category":"section"},{"location":"tutorial/#Step-1:-Install-Julia","page":"Tutorial","title":"Step 1: Install Julia","text":"If you haven't already, download and install Julia from julialang.org.","category":"section"},{"location":"tutorial/#Step-2:-Install-BayesInteractomics","page":"Tutorial","title":"Step 2: Install BayesInteractomics","text":"Open the Julia REPL and install the package:\n\nusing Pkg\nPkg.add(url=\"https://github.com/ma-seefelder/BayesInteractomics.jl\")\n\nThis will install BayesInteractomics and all its dependencies. The first installation may take a few minutes.","category":"section"},{"location":"tutorial/#Step-3:-Verify-Installation","page":"Tutorial","title":"Step 3: Verify Installation","text":"Load the package to verify it works:\n\nusing BayesInteractomics\n\nIf you see no errors, you're ready to proceed!","category":"section"},{"location":"tutorial/#Understanding-Your-Data","page":"Tutorial","title":"Understanding Your Data","text":"","category":"section"},{"location":"tutorial/#Experimental-Design","page":"Tutorial","title":"Experimental Design","text":"BayesInteractomics is designed for comparative proteomics experiments:\n\nControl samples: Negative controls (e.g., empty vector, no-bait)\nBait samples: Samples expressing your protein of interest (bait)\nReplicates: Multiple biological or technical replicates for each condition\nProtocols: Different experimental methods (e.g., different AP-MS protocols, BioID vs. APEX)","category":"section"},{"location":"tutorial/#Data-Format-Requirements","page":"Tutorial","title":"Data Format Requirements","text":"Your data should be organized as:\n\nRows: Proteins (one protein per row)\nColumns: Samples (one sample per column)\nValues: Protein intensities/abundances (log2 scale recommended)\nFirst column: Protein identifiers (e.g., UniProt IDs, gene names)\nMissing data: Leave cells empty or use NA/missing\n\nSupported file formats:\n\nExcel (.xlsx) - recommended\nCSV (.csv)\n\nExample structure:\n\n| Protein      | Control_1 | Control_2 | Control_3 | Sample_1 | Sample_2 | Sample_3 |\n|--------------|-----------|-----------|-----------|----------|----------|----------|\n| PROTEIN_A    | 25.3      | 24.8      | 25.1      | 28.5     | 29.2     | 28.8     |\n| PROTEIN_B    | 22.1      | NA        | 22.3      | 22.5     | 22.0     | 22.8     |\n| BAIT_PROTEIN | 18.2      | 18.5      | 18.0      | 32.1     | 31.8     | 32.5     |","category":"section"},{"location":"tutorial/#Step-by-Step-Analysis","page":"Tutorial","title":"Step-by-Step Analysis","text":"","category":"section"},{"location":"tutorial/#Step-1:-Prepare-Your-File-Paths","page":"Tutorial","title":"Step 1: Prepare Your File Paths","text":"First, define where your data files are located:\n\nusing BayesInteractomics\n\n# Define base directory\nbase_dir = \"/path/to/your/data\"\n\n# Data files (can be multiple protocols)\ndata_files = [joinpath(base_dir, \"protocol1_data.xlsx\")]\n\n# Output directory\noutput_dir = joinpath(base_dir, \"results\")\nmkpath(output_dir)  # Create directory if it doesn't exist","category":"section"},{"location":"tutorial/#Step-2:-Specify-Column-Mappings","page":"Tutorial","title":"Step 2: Specify Column Mappings","text":"BayesInteractomics needs to know which columns contain your samples and controls. Use dictionaries to map experiment IDs to column indices:\n\n# Example: Single protocol with 2 experiments\n# Experiment 1: columns 2-4 are controls, 5-7 are samples\n# Experiment 2: columns 8-10 are controls, 11-13 are samples\n\ncontrol_columns = [\n    Dict(\n        1 => [2, 3, 4],      # Experiment 1 controls\n        2 => [8, 9, 10]      # Experiment 2 controls\n    )\n]\n\nsample_columns = [\n    Dict(\n        1 => [5, 6, 7],      # Experiment 1 samples\n        2 => [11, 12, 13]    # Experiment 2 samples\n    )\n]\n\nImportant: Column indices are 1-based (Julia convention). Column 1 is typically protein IDs.","category":"section"},{"location":"tutorial/#Step-3:-Configure-the-Analysis","page":"Tutorial","title":"Step 3: Configure the Analysis","text":"Create a CONFIG struct with all analysis parameters:\n\nconfig = CONFIG(\n    # Input data\n    datafile = data_files,\n    control_cols = control_columns,\n    sample_cols = sample_columns,\n\n    # Protein identification\n    poi = \"UNIPROT_ID_OF_BAIT\",  # Your bait protein identifier\n    refID = 1,                    # Row index of bait protein in data\n\n    # Sample sizes\n    n_controls = 6,   # Total number of control samples (3 + 3 in example)\n    n_samples = 6,    # Total number of bait samples (3 + 3 in example)\n\n    # Protocol normalization\n    normalise_protocols = true,  # Set true if combining multiple protocols\n\n    # Output files\n    H0_file = joinpath(output_dir, \"copula_H0.xlsx\"),\n    results_file = joinpath(output_dir, \"interaction_results.xlsx\"),\n    volcano_file = joinpath(output_dir, \"volcano_plot.svg\"),\n    convergence_file = joinpath(output_dir, \"convergence_diagnostics.svg\"),\n    evidence_file = joinpath(output_dir, \"evidence_distribution.svg\"),\n\n    # Visualization options\n    plotHBMdists = false,      # Plot HBM distributions for each protein\n    plotlog2fc = false,        # Plot log2 fold change distributions\n    plotregr = false,          # Plot regression fits\n    plotbayesrange = false,    # Plot Bayes factor ranges\n\n    # Other options\n    verbose = true             # Print progress messages\n)","category":"section"},{"location":"tutorial/#Step-4:-Run-the-Analysis","page":"Tutorial","title":"Step 4: Run the Analysis","text":"Now execute the complete analysis pipeline:\n\n# This runs all three models, fits the copula mixture, and generates results\nresults = run_analysis(config)\n\nThe analysis will:\n\nLoad and validate your data\nCompute null hypothesis copula (H0) from negative proteins\nAnalyze each protein with three statistical models (in parallel)\nFit mixture copula to combine evidence\nGenerate results table and visualizations\n\nThis typically takes 5-15 minutes for ~1000 proteins on a modern laptop.","category":"section"},{"location":"tutorial/#Step-5:-Explore-the-Results","page":"Tutorial","title":"Step 5: Explore the Results","text":"The results is a DataFrame containing:\n\n# View column names\nnames(results)\n\n# View top 10 interactions by posterior probability\ntop_hits = first(sort(results, :Posterior_Probability, rev=true), 10)\nprintln(top_hits)\n\n# Filter for high-confidence interactions\nhigh_confidence = filter(row -> row.Posterior_Probability > 0.95, results)\nprintln(\"Found $(nrow(high_confidence)) high-confidence interactions\")","category":"section"},{"location":"tutorial/#Interpreting-Results","page":"Tutorial","title":"Interpreting Results","text":"","category":"section"},{"location":"tutorial/#Key-Output-Columns","page":"Tutorial","title":"Key Output Columns","text":"Protein: Protein identifier from your input data\nIndividual Bayes Factors:\nBF_enrichment: Evidence from quantitative enrichment (HBM)\nBF_correlation: Evidence from dose-response correlation (regression)\nBF_detection: Evidence from detection probability (Beta-Bernoulli)\nValues > 1 support interaction; > 10 is strong; > 100 is very strong\nCombined Evidence:\nCombined_BF: Joint Bayes factor from copula combination\nPosterior_Probability: Final probability of genuine interaction (0-1 scale)\nEnrichment Statistics:\nlog2FC_mean, log2FC_median: Estimated log2 fold change\nlog2FC_sd: Uncertainty in enrichment\npd: Probability of direction (% of posterior > 0)\nrope_percentage: % of posterior in \"region of practical equivalence\" (near zero)\nQuality Metrics:\ness_bulk, ess_tail: Effective sample size (should be > 400 for reliable inference)\nrhat: Convergence diagnostic (should be < 1.01)","category":"section"},{"location":"tutorial/#Decision-Thresholds","page":"Tutorial","title":"Decision Thresholds","text":"Recommended interpretation:\n\nPosterior Probability Interpretation\n> 0.95 Strong evidence for interaction - high confidence hit\n0.75 - 0.95 Moderate evidence - promising candidate, validate experimentally\n0.25 - 0.75 Ambiguous - insufficient evidence either way\n< 0.25 Strong evidence against - likely non-specific or contaminant\n\nImportant: Always consider biological context and validate key interactions experimentally!","category":"section"},{"location":"tutorial/#Visualizations","page":"Tutorial","title":"Visualizations","text":"BayesInteractomics generates several diagnostic plots:\n\nVolcano Plot (volcano_plot.svg):\nX-axis: log2 fold change (enrichment)\nY-axis: -log10(1 - Posterior Probability)\nPoints colored by posterior probability\nHelps identify enriched and high-probability interactions\nConvergence Diagnostics (convergence_diagnostics.svg):\nShows model convergence for proteins\nCheck that most proteins have good convergence (low Rhat)\nEvidence Distribution (evidence_distribution.svg):\nShows distribution of Bayes factors across proteins\nHelps assess overall data quality","category":"section"},{"location":"tutorial/#Advanced-Usage","page":"Tutorial","title":"Advanced Usage","text":"","category":"section"},{"location":"tutorial/#Multiple-Protocols","page":"Tutorial","title":"Multiple Protocols","text":"If you have data from different experimental methods (e.g., AP-MS and BioID):\n\nconfig = CONFIG(\n    datafile = [\n        \"data/apms_protocol.xlsx\",\n        \"data/bioid_protocol.xlsx\"\n    ],\n    control_cols = [\n        Dict(1 => [2,3,4]),      # AP-MS controls\n        Dict(1 => [2,3])         # BioID controls\n    ],\n    sample_cols = [\n        Dict(1 => [5,6,7]),      # AP-MS samples\n        Dict(1 => [4,5])         # BioID samples\n    ],\n    normalise_protocols = true,  # IMPORTANT: set true for multiple protocols\n    # ... rest of configuration\n)","category":"section"},{"location":"tutorial/#Multiple-Imputation","page":"Tutorial","title":"Multiple Imputation","text":"For datasets with substantial missing data, use multiple imputation:\n\n# First, impute your data using your preferred method\n# (e.g., MissForest, KNN, etc.) to create M imputed datasets\n\n# Load imputed datasets\nimputed_data = [\n    load_data([imputed_file_1], sample_cols, control_cols),\n    load_data([imputed_file_2], sample_cols, control_cols),\n    # ... M imputed datasets\n]\n\n# Load raw data for detection model\nraw_data = load_data([\"raw_data.xlsx\"], sample_cols, control_cols)\n\n# Run analysis across imputations\nresults = run_analysis(imputed_data, raw_data, config)\n\nThe package will pool results across imputations following Rubin's rules.","category":"section"},{"location":"tutorial/#Troubleshooting","page":"Tutorial","title":"Troubleshooting","text":"","category":"section"},{"location":"tutorial/#Common-Issues","page":"Tutorial","title":"Common Issues","text":"Problem: \"Column index out of bounds\"\n\nSolution: Check that your column indices are correct and 1-based. Remember column 1 is typically protein IDs.\n\nProblem: \"refID protein not found\"\n\nSolution: Verify that refID corresponds to the correct row number of your bait protein in the data file.\n\nProblem: \"Not enough control/sample columns\"\n\nSolution: Ensure n_controls and n_samples match the total number of columns specified in control_cols and sample_cols.\n\nProblem: Poor convergence (high Rhat values)\n\nSolution: This can happen for proteins with extreme missing data or very low signal. Filter results by rhat < 1.01 for reliable proteins only.\n\nProblem: All posterior probabilities near 0.5\n\nSolution: Check data quality. This suggests weak signal-to-noise. Consider:\nAre controls truly negative?\nIs bait protein detected at sufficient levels?\nAre there enough replicates?","category":"section"},{"location":"tutorial/#Getting-Help","page":"Tutorial","title":"Getting Help","text":"If you encounter issues not covered here:\n\nCheck the User Guide for detailed explanations\nReview Examples for similar use cases\nOpen an issue on GitHub","category":"section"},{"location":"tutorial/#Next-Steps","page":"Tutorial","title":"Next Steps","text":"Now that you've completed your first analysis:\n\nExplore the User Guide: Learn about individual model components and customization\nRead Mathematical Background: Understand the statistical theory behind the methods\nStudy Examples: See real-world analysis workflows\nExperiment with Visualization: Customize plots for your publication needs","category":"section"},{"location":"tutorial/#Recommended-Reading","page":"Tutorial","title":"Recommended Reading","text":"Data Loading: Detailed data structure explanation\nModel Fitting: Understanding the three statistical models\nModel Evaluation: Advanced interpretation of Bayes factors\nMathematical Background: Statistical theory and derivations","category":"section"}]
}
